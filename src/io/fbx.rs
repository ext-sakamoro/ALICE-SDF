//! FBX 7.4 ASCII export for ALICE-SDF meshes
//!
//! Exports meshes to Autodesk FBX 7.4 ASCII format, compatible with:
//! - Maya, 3ds Max, MotionBuilder
//! - UE5 (import)
//! - Unity (import)
//! - Blender (import via plugin)
//!
//! # Limitations
//! - ASCII format only (binary FBX requires Autodesk SDK)
//! - Geometry + materials (no skeleton/animation)
//! - Single mesh per file
//!
//! Author: Moroya Sakamoto

use crate::io::IoError;
use crate::material::MaterialLibrary;
use crate::mesh::Mesh;
use std::io::Write;
use std::path::Path;

/// FBX file format
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum FbxFormat {
    /// ASCII text format (human-readable, larger files)
    Ascii,
    /// Binary format (compact, faster I/O, industry standard)
    Binary,
}

/// FBX export configuration
#[derive(Debug, Clone)]
pub struct FbxConfig {
    /// Export normals
    pub export_normals: bool,
    /// Export UVs
    pub export_uvs: bool,
    /// Export materials
    pub export_materials: bool,
    /// Up axis: "Y" (Maya/UE5) or "Z" (3ds Max/Blender)
    pub up_axis: FbxUpAxis,
    /// File format (ASCII or Binary)
    pub format: FbxFormat,
}

/// FBX up axis convention
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum FbxUpAxis {
    /// Y-up (Maya, UE5, Unity default)
    Y,
    /// Z-up (3ds Max, Blender)
    Z,
}

impl Default for FbxConfig {
    fn default() -> Self {
        FbxConfig {
            export_normals: true,
            export_uvs: true,
            export_materials: true,
            up_axis: FbxUpAxis::Y,
            format: FbxFormat::Ascii,
        }
    }
}

impl FbxConfig {
    /// Binary format config (recommended for large meshes)
    pub fn binary() -> Self {
        FbxConfig {
            format: FbxFormat::Binary,
            ..Default::default()
        }
    }
}

/// Export a mesh to FBX format (dispatches based on config.format)
pub fn export_fbx(
    mesh: &Mesh,
    path: impl AsRef<Path>,
    config: &FbxConfig,
    materials: Option<&MaterialLibrary>,
) -> Result<(), IoError> {
    match config.format {
        FbxFormat::Ascii => export_fbx_ascii(mesh, path, config, materials),
        FbxFormat::Binary => export_fbx_binary(mesh, path, config, materials),
    }
}

/// Export a mesh to FBX 7.4 ASCII format
fn export_fbx_ascii(
    mesh: &Mesh,
    path: impl AsRef<Path>,
    config: &FbxConfig,
    materials: Option<&MaterialLibrary>,
) -> Result<(), IoError> {
    let file = std::fs::File::create(path)?;
    let mut w = std::io::BufWriter::new(file);

    let vert_count = mesh.vertices.len();
    let tri_count = mesh.indices.len() / 3;

    // FBX Header
    writeln!(w, "; FBX 7.4.0 project file")?;
    writeln!(w, "; Generated by ALICE-SDF")?;
    writeln!(w, ";")?;

    // Header extension
    writeln!(w, "FBXHeaderExtension:  {{")?;
    writeln!(w, "\tFBXHeaderVersion: 1003")?;
    writeln!(w, "\tFBXVersion: 7400")?;
    writeln!(w, "\tCreator: \"ALICE-SDF\"")?;
    writeln!(w, "}}")?;
    writeln!(w)?;

    // Global settings
    let up_axis_val = match config.up_axis {
        FbxUpAxis::Y => 1,
        FbxUpAxis::Z => 2,
    };
    writeln!(w, "GlobalSettings:  {{")?;
    writeln!(w, "\tVersion: 1000")?;
    writeln!(w, "\tProperties70:  {{")?;
    writeln!(w, "\t\tP: \"UpAxis\", \"int\", \"Integer\", \"\",{}", up_axis_val)?;
    writeln!(w, "\t\tP: \"UpAxisSign\", \"int\", \"Integer\", \"\",1")?;
    writeln!(w, "\t\tP: \"FrontAxis\", \"int\", \"Integer\", \"\",2")?;
    writeln!(w, "\t\tP: \"FrontAxisSign\", \"int\", \"Integer\", \"\",1")?;
    writeln!(w, "\t\tP: \"CoordAxis\", \"int\", \"Integer\", \"\",0")?;
    writeln!(w, "\t\tP: \"CoordAxisSign\", \"int\", \"Integer\", \"\",1")?;
    writeln!(w, "\t\tP: \"UnitScaleFactor\", \"double\", \"Number\", \"\",1.0")?;
    writeln!(w, "\t}}")?;
    writeln!(w, "}}")?;
    writeln!(w)?;

    // Object definitions
    let mat_count = materials.map_or(0, |m| m.materials.len());
    let total_objects = 2 + mat_count; // Model + Geometry + Materials
    writeln!(w, "Definitions:  {{")?;
    writeln!(w, "\tVersion: 100")?;
    writeln!(w, "\tCount: {}", total_objects)?;
    writeln!(w, "\tObjectType: \"Model\" {{")?;
    writeln!(w, "\t\tCount: 1")?;
    writeln!(w, "\t}}")?;
    writeln!(w, "\tObjectType: \"Geometry\" {{")?;
    writeln!(w, "\t\tCount: 1")?;
    writeln!(w, "\t}}")?;
    if mat_count > 0 && config.export_materials {
        writeln!(w, "\tObjectType: \"Material\" {{")?;
        writeln!(w, "\t\tCount: {}", mat_count)?;
        writeln!(w, "\t}}")?;
    }
    writeln!(w, "}}")?;
    writeln!(w)?;

    // Objects section
    writeln!(w, "Objects:  {{")?;

    // Geometry
    let geom_id: i64 = 100000;
    writeln!(w, "\tGeometry: {}, \"Geometry::Mesh\", \"Mesh\" {{", geom_id)?;

    // Vertices
    writeln!(w, "\t\tVertices: *{} {{", vert_count * 3)?;
    write!(w, "\t\t\ta: ")?;
    for (i, v) in mesh.vertices.iter().enumerate() {
        if i > 0 { write!(w, ",")?; }
        write!(w, "{},{},{}", v.position.x, v.position.y, v.position.z)?;
    }
    writeln!(w)?;
    writeln!(w, "\t\t}}")?;

    // Polygon vertex index (FBX uses negative index-1 for last vertex in polygon)
    writeln!(w, "\t\tPolygonVertexIndex: *{} {{", tri_count * 3)?;
    write!(w, "\t\t\ta: ")?;
    for t in 0..tri_count {
        if t > 0 { write!(w, ",")?; }
        let a = mesh.indices[t * 3] as i32;
        let b = mesh.indices[t * 3 + 1] as i32;
        let c = mesh.indices[t * 3 + 2] as i32;
        // Last index is bitwise NOT (negative - 1) to signal end of polygon
        write!(w, "{},{},{}", a, b, -(c + 1))?;
    }
    writeln!(w)?;
    writeln!(w, "\t\t}}")?;

    // Normals
    if config.export_normals {
        writeln!(w, "\t\tLayerElementNormal: 0 {{")?;
        writeln!(w, "\t\t\tVersion: 101")?;
        writeln!(w, "\t\t\tName: \"\"")?;
        writeln!(w, "\t\t\tMappingInformationType: \"ByVertice\"")?;
        writeln!(w, "\t\t\tReferenceInformationType: \"Direct\"")?;
        writeln!(w, "\t\t\tNormals: *{} {{", vert_count * 3)?;
        write!(w, "\t\t\t\ta: ")?;
        for (i, v) in mesh.vertices.iter().enumerate() {
            if i > 0 { write!(w, ",")?; }
            write!(w, "{},{},{}", v.normal.x, v.normal.y, v.normal.z)?;
        }
        writeln!(w)?;
        writeln!(w, "\t\t\t}}")?;
        writeln!(w, "\t\t}}")?;
    }

    // UVs
    if config.export_uvs {
        writeln!(w, "\t\tLayerElementUV: 0 {{")?;
        writeln!(w, "\t\t\tVersion: 101")?;
        writeln!(w, "\t\t\tName: \"UVMap\"")?;
        writeln!(w, "\t\t\tMappingInformationType: \"ByVertice\"")?;
        writeln!(w, "\t\t\tReferenceInformationType: \"Direct\"")?;
        writeln!(w, "\t\t\tUV: *{} {{", vert_count * 2)?;
        write!(w, "\t\t\t\ta: ")?;
        for (i, v) in mesh.vertices.iter().enumerate() {
            if i > 0 { write!(w, ",")?; }
            write!(w, "{},{}", v.uv.x, v.uv.y)?;
        }
        writeln!(w)?;
        writeln!(w, "\t\t\t}}")?;
        writeln!(w, "\t\t}}")?;
    }

    // Material layer
    if config.export_materials && mat_count > 0 {
        writeln!(w, "\t\tLayerElementMaterial: 0 {{")?;
        writeln!(w, "\t\t\tVersion: 101")?;
        writeln!(w, "\t\t\tName: \"\"")?;
        writeln!(w, "\t\t\tMappingInformationType: \"ByPolygon\"")?;
        writeln!(w, "\t\t\tReferenceInformationType: \"IndexToDirect\"")?;
        writeln!(w, "\t\t\tMaterials: *{} {{", tri_count)?;
        write!(w, "\t\t\t\ta: ")?;
        for t in 0..tri_count {
            if t > 0 { write!(w, ",")?; }
            let v0 = mesh.indices[t * 3] as usize;
            let mat_id = if v0 < mesh.vertices.len() {
                mesh.vertices[v0].material_id
            } else {
                0
            };
            write!(w, "{}", mat_id)?;
        }
        writeln!(w)?;
        writeln!(w, "\t\t\t}}")?;
        writeln!(w, "\t\t}}")?;
    }

    // Layer definition
    writeln!(w, "\t\tLayer: 0 {{")?;
    writeln!(w, "\t\t\tVersion: 100")?;
    if config.export_normals {
        writeln!(w, "\t\t\tLayerElement:  {{")?;
        writeln!(w, "\t\t\t\tType: \"LayerElementNormal\"")?;
        writeln!(w, "\t\t\t\tTypedIndex: 0")?;
        writeln!(w, "\t\t\t}}")?;
    }
    if config.export_uvs {
        writeln!(w, "\t\t\tLayerElement:  {{")?;
        writeln!(w, "\t\t\t\tType: \"LayerElementUV\"")?;
        writeln!(w, "\t\t\t\tTypedIndex: 0")?;
        writeln!(w, "\t\t\t}}")?;
    }
    if config.export_materials && mat_count > 0 {
        writeln!(w, "\t\t\tLayerElement:  {{")?;
        writeln!(w, "\t\t\t\tType: \"LayerElementMaterial\"")?;
        writeln!(w, "\t\t\t\tTypedIndex: 0")?;
        writeln!(w, "\t\t\t}}")?;
    }
    writeln!(w, "\t\t}}")?;
    writeln!(w, "\t}}")?; // End Geometry

    // Model
    let model_id: i64 = 200000;
    writeln!(w, "\tModel: {}, \"Model::Mesh\", \"Mesh\" {{", model_id)?;
    writeln!(w, "\t\tVersion: 232")?;
    writeln!(w, "\t\tProperties70:  {{")?;
    writeln!(w, "\t\t\tP: \"ScalingMax\", \"Vector3D\", \"Vector\", \"\",0,0,0")?;
    writeln!(w, "\t\t}}")?;
    writeln!(w, "\t\tShading: T")?;
    writeln!(w, "\t\tCulling: \"CullingOff\"")?;
    writeln!(w, "\t}}")?;

    // Materials
    if config.export_materials {
        if let Some(mat_lib) = materials {
            for (i, mat) in mat_lib.materials.iter().enumerate() {
                let mat_id: i64 = 300000 + i as i64;
                writeln!(w, "\tMaterial: {}, \"Material::{}\", \"\" {{", mat_id, mat.name)?;
                writeln!(w, "\t\tVersion: 102")?;
                writeln!(w, "\t\tShadingModel: \"phong\"")?;
                writeln!(w, "\t\tProperties70:  {{")?;
                writeln!(w, "\t\t\tP: \"DiffuseColor\", \"Color\", \"\", \"A\",{},{},{}",
                    mat.base_color[0], mat.base_color[1], mat.base_color[2])?;
                writeln!(w, "\t\t\tP: \"SpecularColor\", \"Color\", \"\", \"A\",{},{},{}",
                    mat.metallic, mat.metallic, mat.metallic)?;
                writeln!(w, "\t\t\tP: \"Shininess\", \"double\", \"Number\", \"\",{}",
                    (1.0 - mat.roughness) * 100.0)?;
                writeln!(w, "\t\t\tP: \"Opacity\", \"double\", \"Number\", \"\",{}",
                    mat.opacity)?;
                if mat.emission_strength > 0.0 {
                    writeln!(w, "\t\t\tP: \"EmissiveColor\", \"Color\", \"\", \"A\",{},{},{}",
                        mat.emission[0], mat.emission[1], mat.emission[2])?;
                    writeln!(w, "\t\t\tP: \"EmissiveFactor\", \"double\", \"Number\", \"\",{}",
                        mat.emission_strength)?;
                }
                writeln!(w, "\t\t}}")?;
                writeln!(w, "\t}}")?;
            }
        }
    }

    writeln!(w, "}}")?; // End Objects
    writeln!(w)?;

    // Connections
    writeln!(w, "Connections:  {{")?;
    // Model -> Root
    writeln!(w, "\tC: \"OO\",{},0", model_id)?;
    // Geometry -> Model
    writeln!(w, "\tC: \"OO\",{},{}", geom_id, model_id)?;
    // Materials -> Model
    if config.export_materials {
        if let Some(mat_lib) = materials {
            for i in 0..mat_lib.materials.len() {
                let mat_id: i64 = 300000 + i as i64;
                writeln!(w, "\tC: \"OO\",{},{}", mat_id, model_id)?;
            }
        }
    }
    writeln!(w, "}}")?;

    w.flush()?;
    Ok(())
}

// ============================================================
// FBX 7.4 Binary Format Writer
// ============================================================

const FBX_BINARY_MAGIC: &[u8; 23] = b"Kaydara FBX Binary  \x00\x1a\x00";
const FBX_BINARY_VERSION: u32 = 7400;

/// Write a single FBX binary node property
fn write_fbx_prop_i32(w: &mut impl Write, val: i32) -> Result<(), IoError> {
    w.write_all(&[b'I'])?;
    w.write_all(&val.to_le_bytes())?;
    Ok(())
}

fn write_fbx_prop_i64(w: &mut impl Write, val: i64) -> Result<(), IoError> {
    w.write_all(&[b'L'])?;
    w.write_all(&val.to_le_bytes())?;
    Ok(())
}

fn write_fbx_prop_f64(w: &mut impl Write, val: f64) -> Result<(), IoError> {
    w.write_all(&[b'D'])?;
    w.write_all(&val.to_le_bytes())?;
    Ok(())
}

fn write_fbx_prop_str(w: &mut impl Write, s: &str) -> Result<(), IoError> {
    w.write_all(&[b'S'])?;
    w.write_all(&(s.len() as u32).to_le_bytes())?;
    w.write_all(s.as_bytes())?;
    Ok(())
}

fn write_fbx_prop_f64_array(w: &mut impl Write, data: &[f64]) -> Result<(), IoError> {
    w.write_all(&[b'd'])?;
    w.write_all(&(data.len() as u32).to_le_bytes())?;
    w.write_all(&0u32.to_le_bytes())?; // encoding: 0 = raw
    w.write_all(&((data.len() * 8) as u32).to_le_bytes())?; // compressed_len
    for &v in data {
        w.write_all(&v.to_le_bytes())?;
    }
    Ok(())
}

fn write_fbx_prop_i32_array(w: &mut impl Write, data: &[i32]) -> Result<(), IoError> {
    w.write_all(&[b'i'])?;
    w.write_all(&(data.len() as u32).to_le_bytes())?;
    w.write_all(&0u32.to_le_bytes())?; // encoding: 0 = raw
    w.write_all(&((data.len() * 4) as u32).to_le_bytes())?; // compressed_len
    for &v in data {
        w.write_all(&v.to_le_bytes())?;
    }
    Ok(())
}

/// Serialize an FBX binary node to a buffer.
/// Returns the serialized bytes.
fn serialize_fbx_node(
    name: &str,
    props: &[FbxProp],
    children: &[Vec<u8>],
) -> Vec<u8> {
    let mut body = Vec::new();

    // Properties
    let mut prop_data = Vec::new();
    for prop in props {
        match prop {
            FbxProp::I32(v) => { write_fbx_prop_i32(&mut prop_data, *v).ok(); }
            FbxProp::I64(v) => { write_fbx_prop_i64(&mut prop_data, *v).ok(); }
            FbxProp::F64(v) => { write_fbx_prop_f64(&mut prop_data, *v).ok(); }
            FbxProp::Str(s) => { write_fbx_prop_str(&mut prop_data, s).ok(); }
            FbxProp::F64Array(a) => { write_fbx_prop_f64_array(&mut prop_data, a).ok(); }
            FbxProp::I32Array(a) => { write_fbx_prop_i32_array(&mut prop_data, a).ok(); }
        }
    }

    // Children
    let mut children_data = Vec::new();
    for child in children {
        children_data.extend_from_slice(child);
    }
    // Null record (13 zero bytes) if there are children
    if !children.is_empty() {
        children_data.extend_from_slice(&[0u8; 13]);
    }

    // Node header: end_offset(u32) + num_properties(u32) + prop_list_len(u32) + name_len(u8) + name
    let header_size = 4 + 4 + 4 + 1 + name.len();
    let end_offset = header_size + prop_data.len() + children_data.len();

    body.extend_from_slice(&(end_offset as u32).to_le_bytes());
    body.extend_from_slice(&(props.len() as u32).to_le_bytes());
    body.extend_from_slice(&(prop_data.len() as u32).to_le_bytes());
    body.push(name.len() as u8);
    body.extend_from_slice(name.as_bytes());
    body.extend_from_slice(&prop_data);
    body.extend_from_slice(&children_data);

    body
}

enum FbxProp {
    I32(i32),
    I64(i64),
    F64(f64),
    Str(String),
    F64Array(Vec<f64>),
    I32Array(Vec<i32>),
}

/// Export a mesh to FBX 7.4 binary format
fn export_fbx_binary(
    mesh: &Mesh,
    path: impl AsRef<Path>,
    config: &FbxConfig,
    materials: Option<&MaterialLibrary>,
) -> Result<(), IoError> {
    let file = std::fs::File::create(path)?;
    let mut w = std::io::BufWriter::new(file);

    let vert_count = mesh.vertices.len();
    let tri_count = mesh.indices.len() / 3;

    // FBX binary header
    w.write_all(FBX_BINARY_MAGIC)?;
    w.write_all(&FBX_BINARY_VERSION.to_le_bytes())?;

    // We'll build all top-level nodes as byte buffers, then write them
    // with correct end_offsets (absolute file position).
    let mut top_nodes: Vec<Vec<u8>> = Vec::new();

    // --- FBXHeaderExtension ---
    {
        let version_node = serialize_fbx_node("FBXHeaderVersion", &[FbxProp::I32(1003)], &[]);
        let fbx_version = serialize_fbx_node("FBXVersion", &[FbxProp::I32(7400)], &[]);
        let creator = serialize_fbx_node("Creator", &[FbxProp::Str("ALICE-SDF".to_string())], &[]);
        top_nodes.push(serialize_fbx_node(
            "FBXHeaderExtension", &[],
            &[version_node, fbx_version, creator],
        ));
    }

    // --- GlobalSettings ---
    {
        let up_axis_val = match config.up_axis {
            FbxUpAxis::Y => 1,
            FbxUpAxis::Z => 2,
        };
        let p_nodes = vec![
            serialize_fbx_node("P", &[
                FbxProp::Str("UpAxis".to_string()),
                FbxProp::Str("int".to_string()),
                FbxProp::Str("Integer".to_string()),
                FbxProp::Str(String::new()),
                FbxProp::I32(up_axis_val),
            ], &[]),
            serialize_fbx_node("P", &[
                FbxProp::Str("UpAxisSign".to_string()),
                FbxProp::Str("int".to_string()),
                FbxProp::Str("Integer".to_string()),
                FbxProp::Str(String::new()),
                FbxProp::I32(1),
            ], &[]),
            serialize_fbx_node("P", &[
                FbxProp::Str("UnitScaleFactor".to_string()),
                FbxProp::Str("double".to_string()),
                FbxProp::Str("Number".to_string()),
                FbxProp::Str(String::new()),
                FbxProp::F64(1.0),
            ], &[]),
        ];
        let props70 = serialize_fbx_node("Properties70", &[], &p_nodes);
        let version = serialize_fbx_node("Version", &[FbxProp::I32(1000)], &[]);
        top_nodes.push(serialize_fbx_node("GlobalSettings", &[], &[version, props70]));
    }

    // --- Objects ---
    {
        let mut object_children = Vec::new();
        let geom_id: i64 = 100000;
        let model_id: i64 = 200000;

        // Geometry node
        {
            let mut geom_children = Vec::new();

            // Vertices
            let verts_f64: Vec<f64> = mesh.vertices.iter()
                .flat_map(|v| vec![v.position.x as f64, v.position.y as f64, v.position.z as f64])
                .collect();
            geom_children.push(serialize_fbx_node("Vertices", &[FbxProp::F64Array(verts_f64)], &[]));

            // PolygonVertexIndex
            let indices_i32: Vec<i32> = (0..tri_count).flat_map(|t| {
                let a = mesh.indices[t * 3] as i32;
                let b = mesh.indices[t * 3 + 1] as i32;
                let c = mesh.indices[t * 3 + 2] as i32;
                vec![a, b, -(c + 1)]
            }).collect();
            geom_children.push(serialize_fbx_node("PolygonVertexIndex", &[FbxProp::I32Array(indices_i32)], &[]));

            // Normals
            if config.export_normals {
                let normals_f64: Vec<f64> = mesh.vertices.iter()
                    .flat_map(|v| vec![v.normal.x as f64, v.normal.y as f64, v.normal.z as f64])
                    .collect();
                let normals_node = serialize_fbx_node("Normals", &[FbxProp::F64Array(normals_f64)], &[]);
                let mapping = serialize_fbx_node("MappingInformationType", &[FbxProp::Str("ByVertice".to_string())], &[]);
                let reference = serialize_fbx_node("ReferenceInformationType", &[FbxProp::Str("Direct".to_string())], &[]);
                let version = serialize_fbx_node("Version", &[FbxProp::I32(101)], &[]);
                geom_children.push(serialize_fbx_node("LayerElementNormal", &[FbxProp::I32(0)], &[version, mapping, reference, normals_node]));
            }

            // UVs
            if config.export_uvs {
                let uvs_f64: Vec<f64> = mesh.vertices.iter()
                    .flat_map(|v| vec![v.uv.x as f64, v.uv.y as f64])
                    .collect();
                let uv_node = serialize_fbx_node("UV", &[FbxProp::F64Array(uvs_f64)], &[]);
                let name = serialize_fbx_node("Name", &[FbxProp::Str("UVMap".to_string())], &[]);
                let mapping = serialize_fbx_node("MappingInformationType", &[FbxProp::Str("ByVertice".to_string())], &[]);
                let reference = serialize_fbx_node("ReferenceInformationType", &[FbxProp::Str("Direct".to_string())], &[]);
                let version = serialize_fbx_node("Version", &[FbxProp::I32(101)], &[]);
                geom_children.push(serialize_fbx_node("LayerElementUV", &[FbxProp::I32(0)], &[version, name, mapping, reference, uv_node]));
            }

            // Materials layer
            let mat_count = materials.map_or(0, |m| m.materials.len());
            if config.export_materials && mat_count > 0 {
                let mat_ids: Vec<i32> = (0..tri_count).map(|t| {
                    let v0 = mesh.indices[t * 3] as usize;
                    if v0 < vert_count { mesh.vertices[v0].material_id as i32 } else { 0 }
                }).collect();
                let mat_data = serialize_fbx_node("Materials", &[FbxProp::I32Array(mat_ids)], &[]);
                let mapping = serialize_fbx_node("MappingInformationType", &[FbxProp::Str("ByPolygon".to_string())], &[]);
                let reference = serialize_fbx_node("ReferenceInformationType", &[FbxProp::Str("IndexToDirect".to_string())], &[]);
                let version = serialize_fbx_node("Version", &[FbxProp::I32(101)], &[]);
                geom_children.push(serialize_fbx_node("LayerElementMaterial", &[FbxProp::I32(0)], &[version, mapping, reference, mat_data]));
            }

            // Layer
            {
                let mut layer_children = vec![
                    serialize_fbx_node("Version", &[FbxProp::I32(100)], &[]),
                ];
                if config.export_normals {
                    let le = serialize_fbx_node("LayerElement", &[], &[
                        serialize_fbx_node("Type", &[FbxProp::Str("LayerElementNormal".to_string())], &[]),
                        serialize_fbx_node("TypedIndex", &[FbxProp::I32(0)], &[]),
                    ]);
                    layer_children.push(le);
                }
                if config.export_uvs {
                    let le = serialize_fbx_node("LayerElement", &[], &[
                        serialize_fbx_node("Type", &[FbxProp::Str("LayerElementUV".to_string())], &[]),
                        serialize_fbx_node("TypedIndex", &[FbxProp::I32(0)], &[]),
                    ]);
                    layer_children.push(le);
                }
                if config.export_materials && mat_count > 0 {
                    let le = serialize_fbx_node("LayerElement", &[], &[
                        serialize_fbx_node("Type", &[FbxProp::Str("LayerElementMaterial".to_string())], &[]),
                        serialize_fbx_node("TypedIndex", &[FbxProp::I32(0)], &[]),
                    ]);
                    layer_children.push(le);
                }
                geom_children.push(serialize_fbx_node("Layer", &[FbxProp::I32(0)], &layer_children));
            }

            object_children.push(serialize_fbx_node("Geometry", &[
                FbxProp::I64(geom_id),
                FbxProp::Str("Geometry::Mesh\x00\x01Mesh".to_string()),
                FbxProp::Str("Mesh".to_string()),
            ], &geom_children));
        }

        // Model node
        {
            let props70 = serialize_fbx_node("Properties70", &[], &[
                serialize_fbx_node("P", &[
                    FbxProp::Str("ScalingMax".to_string()),
                    FbxProp::Str("Vector3D".to_string()),
                    FbxProp::Str("Vector".to_string()),
                    FbxProp::Str(String::new()),
                    FbxProp::F64(0.0), FbxProp::F64(0.0), FbxProp::F64(0.0),
                ], &[]),
            ]);
            let version = serialize_fbx_node("Version", &[FbxProp::I32(232)], &[]);
            object_children.push(serialize_fbx_node("Model", &[
                FbxProp::I64(model_id),
                FbxProp::Str("Model::Mesh\x00\x01Mesh".to_string()),
                FbxProp::Str("Mesh".to_string()),
            ], &[version, props70]));
        }

        // Material nodes
        if config.export_materials {
            if let Some(mat_lib) = materials {
                for (i, mat) in mat_lib.materials.iter().enumerate() {
                    let mat_id: i64 = 300000 + i as i64;
                    let p_nodes = vec![
                        serialize_fbx_node("P", &[
                            FbxProp::Str("DiffuseColor".to_string()),
                            FbxProp::Str("Color".to_string()),
                            FbxProp::Str(String::new()),
                            FbxProp::Str("A".to_string()),
                            FbxProp::F64(mat.base_color[0] as f64),
                            FbxProp::F64(mat.base_color[1] as f64),
                            FbxProp::F64(mat.base_color[2] as f64),
                        ], &[]),
                        serialize_fbx_node("P", &[
                            FbxProp::Str("Shininess".to_string()),
                            FbxProp::Str("double".to_string()),
                            FbxProp::Str("Number".to_string()),
                            FbxProp::Str(String::new()),
                            FbxProp::F64(((1.0 - mat.roughness) * 100.0) as f64),
                        ], &[]),
                        serialize_fbx_node("P", &[
                            FbxProp::Str("Opacity".to_string()),
                            FbxProp::Str("double".to_string()),
                            FbxProp::Str("Number".to_string()),
                            FbxProp::Str(String::new()),
                            FbxProp::F64(mat.opacity as f64),
                        ], &[]),
                    ];
                    let props70 = serialize_fbx_node("Properties70", &[], &p_nodes);
                    let version = serialize_fbx_node("Version", &[FbxProp::I32(102)], &[]);
                    let shading = serialize_fbx_node("ShadingModel", &[FbxProp::Str("phong".to_string())], &[]);

                    let mat_name = format!("Material::{}\x00\x01", mat.name);
                    object_children.push(serialize_fbx_node("Material", &[
                        FbxProp::I64(mat_id),
                        FbxProp::Str(mat_name),
                        FbxProp::Str(String::new()),
                    ], &[version, shading, props70]));
                }
            }
        }

        top_nodes.push(serialize_fbx_node("Objects", &[], &object_children));
    }

    // --- Connections ---
    {
        let model_id: i64 = 200000;
        let geom_id: i64 = 100000;
        let mut conn_children = Vec::new();

        conn_children.push(serialize_fbx_node("C", &[
            FbxProp::Str("OO".to_string()),
            FbxProp::I64(model_id),
            FbxProp::I64(0),
        ], &[]));
        conn_children.push(serialize_fbx_node("C", &[
            FbxProp::Str("OO".to_string()),
            FbxProp::I64(geom_id),
            FbxProp::I64(model_id),
        ], &[]));

        if config.export_materials {
            if let Some(mat_lib) = materials {
                for i in 0..mat_lib.materials.len() {
                    let mat_id: i64 = 300000 + i as i64;
                    conn_children.push(serialize_fbx_node("C", &[
                        FbxProp::Str("OO".to_string()),
                        FbxProp::I64(mat_id),
                        FbxProp::I64(model_id),
                    ], &[]));
                }
            }
        }

        top_nodes.push(serialize_fbx_node("Connections", &[], &conn_children));
    }

    // Write all top-level nodes with correct absolute end_offsets
    let header_size = 27u32; // 23 magic + 4 version
    let mut current_offset = header_size;

    for node_data in &top_nodes {
        // Patch the end_offset (first 4 bytes) to be absolute
        let absolute_end = current_offset + node_data.len() as u32;
        let mut patched = node_data.clone();
        patched[0..4].copy_from_slice(&absolute_end.to_le_bytes());
        w.write_all(&patched)?;
        current_offset = absolute_end;
    }

    // Footer: null record
    w.write_all(&[0u8; 13])?;

    w.flush()?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::mesh::{sdf_to_mesh, MarchingCubesConfig};
    use crate::types::SdfNode;
    use glam::Vec3;

    #[test]
    fn test_fbx_export() {
        let sphere = SdfNode::sphere(1.0);
        let config = MarchingCubesConfig {
            resolution: 8,
            iso_level: 0.0,
            compute_normals: true,
            ..Default::default()
        };
        let mesh = sdf_to_mesh(&sphere, Vec3::splat(-2.0), Vec3::splat(2.0), &config);

        let path = std::env::temp_dir().join("alice_test.fbx");
        export_fbx(&mesh, &path, &FbxConfig::default(), None).unwrap();

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("FBXVersion: 7400"));
        assert!(content.contains("Vertices:"));
        assert!(content.contains("PolygonVertexIndex:"));
        assert!(content.contains("LayerElementNormal:"));
        assert!(content.contains("LayerElementUV:"));

        std::fs::remove_file(&path).ok();
    }

    #[test]
    fn test_fbx_with_materials() {
        let sphere = SdfNode::sphere(1.0);
        let config = MarchingCubesConfig {
            resolution: 8,
            iso_level: 0.0,
            compute_normals: true,
            ..Default::default()
        };
        let mesh = sdf_to_mesh(&sphere, Vec3::splat(-2.0), Vec3::splat(2.0), &config);

        let mut mat_lib = crate::material::MaterialLibrary::new();
        mat_lib.add(crate::material::Material::metal("Steel", 0.7, 0.7, 0.7, 0.4));

        let path = std::env::temp_dir().join("alice_test_mat.fbx");
        export_fbx(&mesh, &path, &FbxConfig::default(), Some(&mat_lib)).unwrap();

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("Material::Default"));
        assert!(content.contains("Material::Steel"));
        assert!(content.contains("DiffuseColor"));

        std::fs::remove_file(&path).ok();
    }

    #[test]
    fn test_fbx_z_up() {
        let sphere = SdfNode::sphere(1.0);
        let config = MarchingCubesConfig {
            resolution: 4,
            iso_level: 0.0,
            compute_normals: true,
            ..Default::default()
        };
        let mesh = sdf_to_mesh(&sphere, Vec3::splat(-2.0), Vec3::splat(2.0), &config);

        let fbx_config = FbxConfig {
            up_axis: FbxUpAxis::Z,
            ..Default::default()
        };

        let path = std::env::temp_dir().join("alice_test_zup.fbx");
        export_fbx(&mesh, &path, &fbx_config, None).unwrap();

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("\"UpAxis\", \"int\", \"Integer\", \"\",2"));

        std::fs::remove_file(&path).ok();
    }

    #[test]
    fn test_fbx_binary_export() {
        let sphere = SdfNode::sphere(1.0);
        let config = MarchingCubesConfig {
            resolution: 8,
            iso_level: 0.0,
            compute_normals: true,
            ..Default::default()
        };
        let mesh = sdf_to_mesh(&sphere, Vec3::splat(-2.0), Vec3::splat(2.0), &config);

        let path = std::env::temp_dir().join("alice_test_binary.fbx");
        export_fbx(&mesh, &path, &FbxConfig::binary(), None).unwrap();

        let bytes = std::fs::read(&path).unwrap();
        // Verify FBX binary magic
        assert_eq!(&bytes[0..21], &FBX_BINARY_MAGIC[0..21],
            "FBX binary magic mismatch");
        // Verify version
        let version = u32::from_le_bytes([bytes[23], bytes[24], bytes[25], bytes[26]]);
        assert_eq!(version, 7400);
        // Should be reasonably sized
        assert!(bytes.len() > 100, "Binary FBX too small: {} bytes", bytes.len());

        std::fs::remove_file(&path).ok();
    }

    #[test]
    fn test_fbx_binary_with_materials() {
        let sphere = SdfNode::sphere(1.0);
        let config = MarchingCubesConfig {
            resolution: 4,
            iso_level: 0.0,
            compute_normals: true,
            ..Default::default()
        };
        let mesh = sdf_to_mesh(&sphere, Vec3::splat(-2.0), Vec3::splat(2.0), &config);

        let mut mat_lib = crate::material::MaterialLibrary::new();
        mat_lib.add(crate::material::Material::metal("Steel", 0.7, 0.7, 0.7, 0.4));

        let path = std::env::temp_dir().join("alice_test_bin_mat.fbx");
        export_fbx(&mesh, &path, &FbxConfig::binary(), Some(&mat_lib)).unwrap();

        let bytes = std::fs::read(&path).unwrap();
        assert_eq!(&bytes[0..21], &FBX_BINARY_MAGIC[0..21]);

        std::fs::remove_file(&path).ok();
    }
}
