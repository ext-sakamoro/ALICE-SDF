//! USD (Universal Scene Description) Export
//!
//! Exports meshes to USDA (ASCII) format compatible with:
//! - Pixar USD Toolset, NVIDIA Omniverse, Apple Reality Composer,
//!   Houdini, Maya (via USD plugin), Blender (via USD addon)
//!
//! # Supported Features
//! - Mesh geometry (positions, normals, UVs, indices)
//! - PBR materials (UsdPreviewSurface)
//! - Transform hierarchy
//!
//! Author: Moroya Sakamoto

use crate::io::IoError;
use crate::material::MaterialLibrary;
use crate::mesh::Mesh;
use std::io::Write;
use std::path::Path;

/// USD up-axis convention
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum UsdUpAxis {
    /// Y-up (default for USD, matches Maya/Blender)
    Y,
    /// Z-up (matches 3ds Max, CAD)
    Z,
}

/// Configuration for USDA export
#[derive(Debug, Clone)]
pub struct UsdConfig {
    /// Up axis convention
    pub up_axis: UsdUpAxis,
    /// Meters per unit (1.0 = meters, 0.01 = centimeters)
    pub meters_per_unit: f64,
    /// Export PBR materials
    pub export_materials: bool,
    /// Export vertex normals
    pub export_normals: bool,
}

impl Default for UsdConfig {
    fn default() -> Self {
        UsdConfig {
            up_axis: UsdUpAxis::Y,
            meters_per_unit: 1.0,
            export_materials: true,
            export_normals: true,
        }
    }
}

/// Export mesh to USDA (ASCII USD) format
pub fn export_usda(
    mesh: &Mesh,
    path: impl AsRef<Path>,
    config: &UsdConfig,
    materials: Option<&MaterialLibrary>,
) -> Result<(), IoError> {
    let file = std::fs::File::create(path)?;
    let mut w = std::io::BufWriter::new(file);

    let up_axis = match config.up_axis {
        UsdUpAxis::Y => "Y",
        UsdUpAxis::Z => "Z",
    };

    // Header
    writeln!(w, "#usda 1.0")?;
    writeln!(w, "(")?;
    writeln!(w, "    upAxis = \"{}\"", up_axis)?;
    writeln!(w, "    metersPerUnit = {}", config.meters_per_unit)?;
    writeln!(w, "    doc = \"Generated by ALICE-SDF\"")?;
    writeln!(w, ")\n")?;

    writeln!(w, "def Xform \"Root\"")?;
    writeln!(w, "{{")?;

    // Mesh
    writeln!(w, "    def Mesh \"Mesh\"")?;
    writeln!(w, "    {{")?;

    // Face vertex counts (all triangles = 3)
    let tri_count = mesh.indices.len() / 3;
    write!(w, "        int[] faceVertexCounts = [")?;
    for i in 0..tri_count {
        if i > 0 {
            write!(w, ", ")?;
        }
        write!(w, "3")?;
    }
    writeln!(w, "]")?;

    // Face vertex indices
    write!(w, "        int[] faceVertexIndices = [")?;
    for (i, idx) in mesh.indices.iter().enumerate() {
        if i > 0 {
            write!(w, ", ")?;
        }
        write!(w, "{}", idx)?;
    }
    writeln!(w, "]")?;

    // Points
    write!(w, "        point3f[] points = [")?;
    for (i, v) in mesh.vertices.iter().enumerate() {
        if i > 0 {
            write!(w, ", ")?;
        }
        write!(w, "({}, {}, {})", v.position.x, v.position.y, v.position.z)?;
    }
    writeln!(w, "]")?;

    // Normals
    if config.export_normals {
        write!(w, "        normal3f[] normals = [")?;
        for (i, v) in mesh.vertices.iter().enumerate() {
            if i > 0 {
                write!(w, ", ")?;
            }
            write!(w, "({}, {}, {})", v.normal.x, v.normal.y, v.normal.z)?;
        }
        writeln!(w, "]")?;
        writeln!(
            w,
            "        uniform token normals:interpolation = \"vertex\""
        )?;
    }

    // UVs
    write!(w, "        texCoord2f[] primvars:st = [")?;
    for (i, v) in mesh.vertices.iter().enumerate() {
        if i > 0 {
            write!(w, ", ")?;
        }
        write!(w, "({}, {})", v.uv.x, v.uv.y)?;
    }
    writeln!(w, "]")?;
    writeln!(
        w,
        "        uniform token primvars:st:interpolation = \"vertex\""
    )?;

    writeln!(w, "        uniform token subdivisionScheme = \"none\"")?;

    if config.export_materials {
        writeln!(
            w,
            "        rel material:binding = </Root/Materials/Material_0>"
        )?;
    }

    writeln!(w, "    }}\n")?;

    // Materials
    if config.export_materials {
        writeln!(w, "    def Scope \"Materials\"")?;
        writeln!(w, "    {{")?;

        let (diffuse_r, diffuse_g, diffuse_b, metallic, roughness, opacity) =
            if let Some(lib) = materials {
                if let Some(mat) = lib.materials.first() {
                    (
                        mat.base_color[0],
                        mat.base_color[1],
                        mat.base_color[2],
                        mat.metallic,
                        mat.roughness,
                        mat.opacity,
                    )
                } else {
                    (0.8, 0.8, 0.8, 0.0, 0.5, 1.0)
                }
            } else {
                (0.8, 0.8, 0.8, 0.0, 0.5, 1.0)
            };

        writeln!(w, "        def Material \"Material_0\"")?;
        writeln!(w, "        {{")?;
        writeln!(w, "            token outputs:surface.connect = </Root/Materials/Material_0/PBR.outputs:surface>")?;
        writeln!(w)?;
        writeln!(w, "            def Shader \"PBR\"")?;
        writeln!(w, "            {{")?;
        writeln!(
            w,
            "                uniform token info:id = \"UsdPreviewSurface\""
        )?;
        writeln!(
            w,
            "                color3f inputs:diffuseColor = ({}, {}, {})",
            diffuse_r, diffuse_g, diffuse_b
        )?;
        writeln!(w, "                float inputs:metallic = {}", metallic)?;
        writeln!(w, "                float inputs:roughness = {}", roughness)?;
        writeln!(w, "                float inputs:opacity = {}", opacity)?;
        writeln!(w, "                token outputs:surface")?;
        writeln!(w, "            }}")?;
        writeln!(w, "        }}")?;
        writeln!(w, "    }}")?;
    }

    writeln!(w, "}}")?;
    w.flush()?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::mesh::{sdf_to_mesh, MarchingCubesConfig};
    use crate::types::SdfNode;
    use glam::Vec3;

    #[test]
    fn test_usda_export() {
        let sphere = SdfNode::sphere(1.0);
        let mesh = sdf_to_mesh(
            &sphere,
            Vec3::splat(-2.0),
            Vec3::splat(2.0),
            &MarchingCubesConfig {
                resolution: 16,
                ..Default::default()
            },
        );

        let path = std::env::temp_dir().join("alice_test.usda");
        export_usda(&mesh, &path, &UsdConfig::default(), None).unwrap();

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("#usda 1.0"));
        assert!(content.contains("upAxis = \"Y\""));
        assert!(content.contains("def Mesh \"Mesh\""));
        assert!(content.contains("point3f[] points"));
        assert!(content.contains("UsdPreviewSurface"));

        std::fs::remove_file(&path).ok();
    }

    #[test]
    fn test_usda_z_up() {
        let sphere = SdfNode::sphere(1.0);
        let mesh = sdf_to_mesh(
            &sphere,
            Vec3::splat(-2.0),
            Vec3::splat(2.0),
            &MarchingCubesConfig {
                resolution: 8,
                ..Default::default()
            },
        );

        let path = std::env::temp_dir().join("alice_test_zup.usda");
        let config = UsdConfig {
            up_axis: UsdUpAxis::Z,
            ..Default::default()
        };
        export_usda(&mesh, &path, &config, None).unwrap();

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("upAxis = \"Z\""));

        std::fs::remove_file(&path).ok();
    }
}
