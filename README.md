# ALICE-SDF

<p align="center">
  <img src="asset/logo-on-light.jpeg" alt="ALICE-SDF Logo" width="720">
</p>

**English** | [日本語](README_JP.md)

**A.L.I.C.E. - Adaptive Lightweight Implicit Compression Engine**

> "Don't send polygons. Send the law of shapes."

## Overview

ALICE-SDF is a 3D/spatial data specialist that transmits **mathematical descriptions of shapes** (Signed Distance Functions) instead of polygon meshes. This enables:

- **10-1000x compression** compared to traditional mesh formats
- **Infinite resolution** - shapes are mathematically perfect at any scale
- **CSG operations** - boolean operations on shapes without mesh overhead
- **Real-time raymarching** - GPU-accelerated rendering
- **PBR materials** - metallic-roughness workflow compatible with UE5/Unity/Godot
- **Keyframe animation** - parametric deformation with timeline tracks
- **Asset pipeline** - OBJ import/export, glTF 2.0 (.glb) export, FBX, USD, Alembic, Nanite export
- **Manifold mesh guarantee** - validation, repair, and quality metrics
- **Adaptive Marching Cubes** - octree-based mesh generation, detail where it matters
- **Dual Contouring** - QEF-based mesh generation that preserves sharp edges and corners
- **V-HACD convex decomposition** - automatic convex hull decomposition for physics
- **Attribute-preserving decimation** - QEM with UV/tangent/material boundary protection
- **Decimation-based LOD** - progressive LOD chain from high-res base mesh
- **53 primitives, 12 operations, 4 transforms, 15 modifiers** - rich shape vocabulary
- **Chamfer & Stairs blends** - hard-edge bevels and stepped/terraced CSG transitions
- **Interval Arithmetic** - conservative AABB evaluation for spatial pruning and Lipschitz bound tracking
- **Relaxed Sphere Tracing** - over-relaxation with Lipschitz-adaptive step sizing
- **Neural SDF** - pure-Rust MLP that approximates an SDF tree ~10-100x faster for complex scenes
- **SDF-to-SDF Collision** - grid-based contact detection with interval arithmetic AABB pruning
- **Analytic Gradient** - single-pass gradient via chain rules and Jacobian propagation (9 analytic + 44 numerical-fallback primitives)
- **7 evaluation modes** - interpreted, compiled VM, SIMD 8-wide, BVH, SoA batch, JIT, GPU
- **3 shader targets** - GLSL, WGSL, HLSL transpilation
- **Engine integrations** - Unity, Unreal Engine 5, VRChat, Godot, WebAssembly

## Text-to-3D Pipeline (Server)

ALICE-SDF includes a FastAPI server that converts **natural language text into real 3D geometry** via LLM-generated SDF trees.

```
User: "A medieval castle"  →  LLM (Claude/Gemini)  →  SDF JSON  →  ALICE-SDF  →  GLB/OBJ
         text                   ~5-50s                  20 nodes      <55ms        mesh
```

### Architecture

```
┌─────────────┐     ┌──────────────┐     ┌───────────────┐     ┌──────────┐
│  FastAPI     │     │  LLM Service │     │  SDF Service  │     │  Output  │
│  Server      │────▶│  Claude API  │────▶│  from_json()  │────▶│  GLB     │
│              │     │  Gemini API  │     │  compile()    │     │  OBJ     │
│  POST /gen   │     │  System      │     │  to_mesh()    │     │  JSON    │
│  WS /ws/gen  │     │  Prompt      │     │  export_glb() │     │  Viewer  │
│  GET /viewer │     └──────────────┘     └───────────────┘     └──────────┘
└─────────────┘
```

### API Endpoints

| Method | Path | Description |
|--------|------|-------------|
| `POST` | `/api/generate` | Text → 3D mesh (GLB/OBJ/JSON) |
| `POST` | `/api/validate` | Validate SDF JSON structure |
| `POST` | `/api/mesh` | SDF JSON → mesh (GLB/OBJ) |
| `GET` | `/api/examples` | List few-shot example scenes |
| `GET` | `/api/viewer` | Three.js GLB viewer (browser) |
| `GET` | `/api/health` | Server health check |
| `WS` | `/ws/generate` | Streaming generation with progressive preview |

### Generated Scene Gallery

Scenes generated by Gemini 2.5 Flash from natural language prompts:

| Prompt | Nodes | Vertices | Triangles | LLM Time |
|--------|-------|----------|-----------|----------|
| "A medieval castle with towers" | 18 | 2,105 | 4,248 | 49.4s |
| "A robot standing on a platform" | 18 | 750 | 1,184 | 17.5s |
| "An underwater coral reef scene" | 15 | 2,666 | 5,166 | 63.3s |
| "A simple mushroom on grass" | 9 | 8,237 | 16,224 | 6.6s |
| "火山地帯に宇宙船" (Volcanic terrain with spaceship) | 22 | 10,466 | 20,618 | 20.5s |

Hand-crafted few-shot examples (used in LLM system prompt):

| Scene | Description | Nodes | Vertices | Triangles |
|-------|-------------|-------|----------|-----------|
| `sphere_on_ground` | Sphere on a flat ground (Union + Plane) | 4 | 1,270 | 2,448 |
| `snowman` | 3-sphere snowman (SmoothUnion) | 8 | 422 | 840 |
| `castle_tower` | Tower with battlements (PolarRepeat) | 11 | 1,030 | 2,244 |
| `alien_mushroom_forest` | Mushroom grid (RepeatFinite + Torus stems) | 9 | 4,167 | 7,854 |
| `twisted_pillar` | Twisted box + floating hollow sphere (Twist + Onion) | 7 | 510 | 968 |
| `mechanical_gear` | Gear with teeth and axle hole (PolarRepeat + Subtraction) | 9 | 465 | 912 |

Scene JSON files are stored in [`server/examples/scenes/`](server/examples/scenes/).

### Quick Start (Server)

```bash
# 1. Build Python bindings
cd /path/to/ALICE-SDF
python -m venv .venv && source .venv/bin/activate
maturin develop --features python

# 2. Install server dependencies
pip install -r server/requirements.txt

# 3. Set API keys
export ANTHROPIC_API_KEY="sk-..."   # for Claude
export GOOGLE_API_KEY="AI..."       # for Gemini

# 4. Start server
uvicorn server.main:app --reload

# 5. Generate 3D from text
curl -X POST http://localhost:8000/api/generate \
  -H "Content-Type: application/json" \
  -d '{"prompt": "A snowman", "provider": "gemini", "resolution": 64}' \
  -o snowman.glb

# 6. Open browser viewer
open http://localhost:8000/api/viewer
```

### LLM Providers

| Provider | Model | Speed | Best For |
|----------|-------|-------|----------|
| Claude | Haiku 4.5 | ~2-5s | Simple scenes, fast iteration |
| Claude | Sonnet 4.5 | ~5-15s | Complex scenes, high accuracy |
| Gemini | 2.5 Flash | ~5-50s | Complex scenes (thinking model) |
| Gemini | 2.5 Pro | ~10-60s | Maximum quality |

### Performance Budget

| Step | Time | Notes |
|------|------|-------|
| LLM inference | 2-60s | Depends on model and complexity |
| JSON parse | <1ms | serde_json |
| SDF compile | ~1ms | SdfNode → CompiledSdf |
| Mesh generation (res=64) | ~45ms | Parallel Marching Cubes |
| GLB export | ~5ms | |
| **Total (excluding LLM)** | **<55ms** | Real-time capable |

### Robustness Features

- **JSON repair**: Automatic brace/bracket completion for truncated LLM output
- **Structure validation**: Pre-validates Boolean ops (a/b) and transforms (child) before Rust serde
- **Retry with feedback**: Up to 2 retries with error message fed back to LLM
- **Rate limit handling**: Automatic wait-and-retry on 429 errors
- **Complexity constraints**: System prompt limits scenes to 15-20 nodes, nesting depth ≤6

### Server Directory Structure

```
server/
├── main.py                  # FastAPI app, REST + WebSocket endpoints
├── config.py                # API keys, model config (env vars)
├── models.py                # Pydantic request/response models
├── services/
│   ├── llm_service.py       # Claude/Gemini API with retry logic
│   └── sdf_service.py       # alice_sdf wrapper (parse, mesh, export)
├── prompts/
│   ├── system_prompt.py     # 36-node-type SDF grammar for LLM
│   └── examples.py          # 6 few-shot examples
├── examples/
│   └── scenes/              # Pre-built scene JSON files
│       ├── sphere_on_ground.json
│       ├── snowman.json
│       ├── castle_tower.json
│       ├── alien_mushroom_forest.json
│       ├── twisted_pillar.json
│       └── mechanical_gear.json
├── static/
│   └── viewer.html          # Three.js GLB viewer
├── tests/
│   ├── test_api.py          # 7 API endpoint tests
│   ├── test_llm_service.py  # 17 JSON extraction/validation tests
│   └── test_sdf_service.py  # 13 SDF pipeline tests
└── requirements.txt
```

### Running Tests

```bash
source .venv/bin/activate
python -m pytest server/tests/ -v   # 37 tests, all passing
```

## ALICE-View (Real-time 3D Viewer)

**[ALICE-View](../ALICE-View)** is a native GPU raymarching viewer built with wgpu. It renders SDF trees directly on the GPU via WGSL transpilation — no mesh conversion needed.

```
SDF JSON → ALICE-SDF (WGSL transpile) → wgpu GPU Raymarching → Real-time 3D
              ~1ms                            60 FPS
```

### Features

- **GPU Raymarching** — SdfNode tree transpiled to WGSL shader, evaluated per-pixel on GPU
- **Drag & Drop** — Drop `.json` / `.asdf` / `.asdf.json` files onto the window
- **File Dialog** — File > Open (Ctrl+O) with format filters
- **Camera Controls** — Mouse orbit, scroll zoom, WASD movement
- **Live SDF Panel** — Node count, raymarching parameters (max steps, epsilon, AO)

### Supported Formats

| Extension | Format | Description |
|-----------|--------|-------------|
| `.json` | SDF JSON | Text-to-3D pipeline output, few-shot examples |
| `.asdf.json` | ALICE SDF JSON | Native ALICE-SDF JSON format |
| `.asdf` | ALICE SDF Binary | Compact binary with CRC32 |
| `.alice` / `.alz` | ALICE Legacy | Procedural content (Perlin, Fractal) |

### Quick Start

```bash
cd /path/to/ALICE-View

# Open a specific file
cargo run --bin alice-view -- path/to/scene.json

# Or launch empty and drag & drop files onto the window
cargo run --bin alice-view
```

### Keyboard Shortcuts

| Key | Action |
|-----|--------|
| `W/A/S/D` | Camera movement |
| `Mouse drag` | Orbit camera |
| `Scroll` | Zoom in/out |
| `Ctrl+O` | Open file dialog |
| `Q` | Quit |

### Viewing Text-to-3D Results

Generated scene JSON files from the Text-to-3D pipeline can be viewed directly:

```bash
# View a generated scene
cargo run --bin alice-view -- /path/to/ALICE-SDF/server/examples/scenes/snowman.json

# Or drag any of these onto the window:
#   server/examples/scenes/castle_tower.json
#   server/examples/scenes/mechanical_gear.json
#   server/examples/scenes/alien_mushroom_forest.json
```

---

## Core Concepts

### SDF (Signed Distance Function)

An SDF returns the shortest distance from any point to the surface:
- **Negative** = inside the shape
- **Zero** = on the surface
- **Positive** = outside the shape

### SdfNode Tree Structure

```
SdfNode
  |-- Primitive (53): Sphere, Box3D, Cylinder, Torus, Plane, Capsule, Cone, Ellipsoid,
  |                    RoundedCone, Pyramid, Octahedron, HexPrism, Link, Triangle, Bezier,
  |                    RoundedBox, CappedCone, CappedTorus, InfiniteCylinder, RoundedCylinder,
  |                    TriangularPrism, CutSphere, CutHollowSphere, DeathStar, SolidAngle,
  |                    Rhombus, Horseshoe, Vesica, InfiniteCone, Heart, Gyroid,
  |                    Tube, Barrel, Diamond, ChamferedCube, SchwarzP, Superellipsoid, RoundedX,
  |                    Pie, Trapezoid, Parallelogram, Tunnel, UnevenCapsule, Egg,
  |                    ArcShape, Moon, CrossShape, BlobbyCross, ParabolaSegment,
  |                    RegularPolygon, StarPolygon, Stairs, Helix
  |-- Operation (12): Union, Intersection, Subtraction,
  |                    SmoothUnion, SmoothIntersection, SmoothSubtraction,
  |                    ChamferUnion, ChamferIntersection, ChamferSubtraction,
  |                    StairsUnion, StairsIntersection, StairsSubtraction
  |-- Transform (4): Translate, Rotate, Scale, ScaleNonUniform
  |-- Modifier (15): Twist, Bend, RepeatInfinite, RepeatFinite, Noise, Round, Onion, Elongate,
  |                   Mirror, Revolution, Extrude, Taper, Displacement, PolarRepeat, SweepBezier
  +-- WithMaterial: PBR material assignment (transparent to distance evaluation)
```

## Installation

### Rust

```bash
cargo add alice-sdf
```

### Python

```bash
pip install alice-sdf
```

## Usage

### Rust

```rust
use alice_sdf::prelude::*;

// Create a sphere with radius 1
let sphere = SdfNode::sphere(1.0);

// Subtract a box from it
let result = sphere.subtract(SdfNode::box3d(1.5, 1.5, 1.5));

// Evaluate distance at a point
let distance = eval(&result, glam::Vec3::ZERO);

// Convert to mesh
let mesh = sdf_to_mesh(
    &result,
    glam::Vec3::splat(-2.0),
    glam::Vec3::splat(2.0),
    &MarchingCubesConfig::default()
);
```

### Python

```python
import alice_sdf as sdf

# Create primitives
sphere = sdf.SdfNode.sphere(1.0)
box3d = sdf.SdfNode.box3d(2.0, 1.0, 1.0)

# CSG operations (method syntax)
result = sphere.subtract(box3d)

# Operator overloads (Pythonic syntax)
a = sdf.SdfNode.sphere(1.0)
b = sdf.SdfNode.box3d(0.5, 0.5, 0.5)
union     = a | b    # a.union(b)
intersect = a & b    # a.intersection(b)
subtract  = a - b    # a.subtract(b)

# Transform
translated = result.translate(1.0, 0.0, 0.0)

# Evaluate at points (NumPy array)
import numpy as np
points = np.array([[0.5, 0.0, 0.0], [1.0, 1.0, 1.0]], dtype=np.float32)
distances = sdf.eval_batch(translated, points)

# Compiled evaluation (2-5x faster for repeated use)
compiled = sdf.compile_sdf(sphere)
distances = compiled.eval_batch(points)               # compiled batch
vertices, indices = compiled.to_mesh((-2,-2,-2), (2,2,2), resolution=64)  # compiled mesh

# Convert to mesh
vertices, indices = sdf.to_mesh(translated, (-2.0, -2.0, -2.0), (2.0, 2.0, 2.0))

# Export to multiple formats
sdf.export_obj(vertices, indices, "model.obj")
sdf.export_glb(vertices, indices, "model.glb")
sdf.export_fbx(vertices, indices, "model.fbx")
sdf.export_usda(vertices, indices, "model.usda")
sdf.export_alembic(vertices, indices, "model.abc")

# UV unwrap → (positions[N,3], uvs[N,2], indices[M])
positions, uvs, indices = sdf.uv_unwrap(vertices, indices)
```

## Material System

PBR metallic-roughness material system compatible with glTF 2.0, UE5, Unity HDRP, and Godot.

### Material Properties

| Property | Type | Description |
|----------|------|-------------|
| `base_color` | `[f32; 4]` | RGBA base color (linear space) |
| `metallic` | `f32` | 0.0 = dielectric, 1.0 = metal |
| `roughness` | `f32` | 0.0 = mirror, 1.0 = diffuse |
| `emission` | `[f32; 3]` | Emissive color (RGB) |
| `emission_strength` | `f32` | Emissive intensity multiplier |
| `opacity` | `f32` | 0.0 = transparent, 1.0 = opaque |
| `ior` | `f32` | Index of refraction (glass=1.5, water=1.33) |
| `normal_scale` | `f32` | Normal map strength |

### Usage

```rust
use alice_sdf::prelude::*;

// Create materials
let gold = Material::metal("Gold", 1.0, 0.766, 0.336, 0.3);
let glass = Material::glass("Glass", 1.5);
let glow = Material::emissive("Neon", 0.0, 1.0, 0.0, 10.0);

// Material library
let mut lib = MaterialLibrary::new();
let gold_id = lib.add(gold);

// Assign material to shape
let sphere = SdfNode::sphere(1.0).with_material(gold_id);

// Generate mesh with AAA vertex format (UV, tangent, color, material_id)
let mesh = sdf_to_mesh(&sphere, Vec3::splat(-2.0), Vec3::splat(2.0), &MarchingCubesConfig::aaa(64));
```

### Vertex Format

The mesh vertex includes all attributes needed for AAA rendering:

| Attribute | Type | Description |
|-----------|------|-------------|
| `position` | `Vec3` | 3D position |
| `normal` | `Vec3` | Surface normal |
| `uv` | `Vec2` | Triplanar-projected texture coordinates |
| `tangent` | `Vec4` | Tangent (xyz=direction, w=handedness) |
| `color` | `[f32; 4]` | Vertex color (RGBA linear) |
| `material_id` | `u32` | Material library index |

## Animation System

Keyframe-based animation of SDF parameters for real-time deformation, morphing, and cinematic sequences.

### Features

- **Interpolation modes**: Linear, Cubic Bezier (Hermite), Step
- **Loop modes**: Once, Loop, PingPong
- **Timeline**: Multiple tracks with named parameters
- **AnimatedSdf**: Time-varying SDF evaluation
- **Morph**: Smooth blending between two SDF shapes

### Usage

```rust
use alice_sdf::prelude::*;

// Create a bouncing sphere animation
let sphere = SdfNode::sphere(1.0);

let mut timeline = Timeline::new("bounce");

let mut ty = Track::new("translate.y").with_loop(LoopMode::PingPong);
ty.add_keyframe(Keyframe::new(0.0, 0.0));
ty.add_keyframe(Keyframe::cubic(0.5, 3.0, 0.0, 0.0));
ty.add_keyframe(Keyframe::new(1.0, 0.0));
timeline.add_track(ty);

let animated = AnimatedSdf::new(sphere, timeline);

// Evaluate at time t=0.25
let node_at_t = animated.evaluate_at(0.25);
let distance = eval(&node_at_t, Vec3::ZERO);

// Morph between two shapes
let sphere = SdfNode::sphere(1.0);
let cube = SdfNode::box3d(1.0, 1.0, 1.0);
let morphed = morph(&sphere, &cube, 0.5); // 50% blend
```

### Supported Track Names

| Track | Description |
|-------|-------------|
| `translate.x/y/z` | Translation offset |
| `rotate.x/y/z` | Euler rotation (radians) |
| `scale` | Uniform scale factor |
| `twist` | Twist strength |
| `bend` | Bend curvature |

## File Formats

### .asdf (ALICE SDF Binary)

Compact binary format with CRC32 integrity check.

```
Header (16 bytes):
  - Magic: "ASDF" (4 bytes)
  - Version: u16 (2 bytes)
  - Flags: u16 (2 bytes)
  - Node count: u32 (4 bytes)
  - CRC32: u32 (4 bytes)

Body:
  - Bincode-serialized SdfTree
```

### .asdf.json (ALICE SDF JSON)

Human-readable JSON format for debugging, interoperability, and LLM generation.

```json
{
  "version": "0.1.0",
  "root": {
    "Subtraction": {
      "a": {"Sphere": {"radius": 1.0}},
      "b": {"Box3d": {"half_extents": [1.5, 1.5, 1.5]}}
    }
  },
  "metadata": null
}
```

This is the same format used by the Text-to-3D pipeline — LLMs generate this JSON directly.

### .obj (Wavefront OBJ)

Standard mesh format with material (.mtl) support.

```rust
use alice_sdf::prelude::*;

let mesh = sdf_to_mesh(&shape, min, max, &MarchingCubesConfig::aaa(64));
export_obj(&mesh, "model.obj", &ObjConfig::default(), Some(&mat_lib))?;
```

### .glb (glTF 2.0 Binary)

Industry-standard 3D format with PBR materials. Compatible with UE5, Unity, Blender, Godot, and web viewers.

```rust
use alice_sdf::prelude::*;

let mesh = sdf_to_mesh(&shape, min, max, &MarchingCubesConfig::aaa(64));
export_glb(&mesh, "model.glb", &GltfConfig::aaa(), Some(&mat_lib))?;
```

### Asset Pipeline Summary

| Format | Import | Export | Materials | Description |
|--------|--------|--------|-----------|-------------|
| `.asdf` | yes | yes | - | Native SDF binary (CRC32) |
| `.asdf.json` | yes | yes | - | Native SDF JSON |
| `.obj` | yes | yes | .mtl | Wavefront OBJ (universal DCC) |
| `.glb` | - | yes | PBR | glTF 2.0 binary (game engines) |
| `.fbx` | - | yes | PBR | FBX 7.4 ASCII/Binary (DCC tools) |
| `.usda` | - | yes | UsdPreviewSurface | USD ASCII (Pixar/Omniverse/Houdini/Maya/Blender) |
| `.abc` | - | yes | - | Alembic Ogawa binary (Maya/Houdini/Nuke/Blender) |
| `.nanite` | - | yes | - | UE5 Nanite hierarchical cluster binary + JSON manifest |

## Architecture

ALICE-SDF uses a layered architecture. Each SDF primitive/operation is implemented across all 16 core layers, plus specialized modules:

```
Layer 1:  types.rs          -- SdfNode enum (AST definition)
Layer 2:  primitives/       -- Mathematical SDF formulas (Inigo Quilez)
Layer 3:  eval/             -- Recursive interpreter
Layer 4:  compiled/opcode   -- OpCode enum for VM
Layer 5:  compiled/instr    -- Instruction encoding (32-byte aligned)
Layer 6:  compiled/compiler -- AST -> instruction compilation
Layer 7:  compiled/eval     -- Stack-based VM evaluator
Layer 8:  compiled/eval_simd-- SIMD 8-wide evaluator (AVX2/NEON)
Layer 9:  compiled/eval_bvh -- BVH-accelerated evaluator (AABB pruning)
Layer 10: compiled/glsl     -- GLSL transpiler (Unity/OpenGL/Vulkan)
Layer 11: compiled/wgsl     -- WGSL transpiler (WebGPU)
Layer 12: compiled/hlsl     -- HLSL transpiler (DirectX/Unreal)
Layer 13: compiled/jit      -- JIT native code scalar (Cranelift)
Layer 14: compiled/jit_simd -- JIT SIMD 8-wide native code (Cranelift)
Layer 15: crispy.rs         -- Hardware-native math (branchless, BitMask64, BloomFilter)
Layer 16: interval.rs       -- Interval arithmetic evaluation + Lipschitz bounds

Specialized modules:
  neural.rs     -- Neural SDF (MLP approximation, training, inference)
  collision.rs  -- SDF-to-SDF contact detection with IA pruning
  eval/gradient -- Analytic gradient (chain rules, Jacobian propagation)
  mesh/dual_contouring -- Dual Contouring (QEF vertex placement, sharp edges)
```

### Evaluation Modes

| Mode | Description | Use Case |
|------|-------------|----------|
| **Interpreted** | Recursive tree walk | Debugging, prototyping |
| **Compiled VM** | Stack-based bytecode | General purpose |
| **SIMD 8-wide** | 8 points in parallel (Vec3x8) | Batch evaluation |
| **BVH-accelerated** | AABB spatial pruning | Complex scenes |
| **SoA Batch** | Structure-of-Arrays memory layout | Cache-optimal SIMD batches |
| **JIT Native** | Cranelift machine code | Maximum throughput |
| **GPU Compute** | WGSL compute shaders | Massive batches |

### Shader Transpilers

| Target | Output | Use Case |
|--------|--------|----------|
| **GLSL** | OpenGL/Vulkan shaders | Unity, custom engines |
| **WGSL** | WebGPU shaders | Browser, wgpu |
| **HLSL** | DirectX shaders | Unreal Engine, DirectX |

#### Engine-Specific Shader Exports

| Method | Output | Target Engine |
|--------|--------|---------------|
| `HlslShader::export_ue5_material_function()` | `.ush` Material Function include | Unreal Engine 5 (Custom Expression) |
| `GlslShader::export_unity_shader_graph()` | `.hlsl` Custom Function node | Unity Shader Graph (HDRP/URP) |

## Mesh Module

### Conversion

| Function | Description |
|----------|-------------|
| `sdf_to_mesh()` | SDF to mesh via parallel marching cubes (Z-slab parallelization) |
| `sdf_to_mesh_compiled()` | Compiled VM path — SIMD batch grid eval + grid finite-difference normals |
| `marching_cubes_compiled()` | Compiled MC with `eval_compiled_batch_simd_parallel` grid evaluation |
| `adaptive_marching_cubes()` | Octree-adaptive MC (interpreted) — 60-80% fewer triangles |
| `adaptive_marching_cubes_compiled()` | Octree-adaptive MC (compiled VM) — 2-5x faster |
| `mesh_to_sdf()` | Mesh to SDF via capsule approximation (edge-based) |
| `mesh_to_sdf_exact()` | Mesh to SDF via BVH exact distance (O(log n) queries) |

### Advanced Features

| Feature | Module | Description |
|---------|--------|-------------|
| **Hermite Data** | `mesh/hermite` | Position + normal extraction for Dual Contouring |
| **Primitive Fitting** | `mesh/primitive_fitting` | Detect sphere/box/cylinder in mesh data for CSG reconstruction |
| **Nanite Clusters** | `mesh/nanite` | UE5 Nanite-compatible hierarchical cluster generation |
| **LOD Generation** | `mesh/lod` | Level-of-detail chain generation for efficient rendering |
| **Decimation LOD** | `mesh/lod` | Progressive decimation-based LOD from high-res base mesh |
| **Adaptive MC** | `mesh/sdf_to_mesh` | Octree-based marching cubes with surface-adaptive subdivision |
| **Mesh Decimation** | `mesh/decimate` | QEM decimation with UV/tangent/material boundary preservation |
| **Convex Decomposition** | `mesh/collision` | V-HACD volumetric convex decomposition for physics |
| **Collision Primitives** | `mesh/collision` | AABB, bounding sphere, convex hull, simplified collision |
| **Lightmap UVs** | `mesh/lightmap` | Automatic lightmap UV generation (UV channel 1) |
| **Vertex Optimization** | `mesh/optimize` | Vertex cache optimization and deduplication |
| **Mesh BVH** | `mesh/bvh` | Bounding volume hierarchy for exact signed distance queries |
| **Manifold Validation** | `mesh/manifold` | Topology validation, repair, and quality metrics |
| **UV Unwrapping** | `mesh/uv_unwrap` | LSCM conformal UV unwrapping with seam detection and chart packing |

## Interval Arithmetic

Conservative evaluation of SDFs over axis-aligned bounding boxes (AABBs). Returns `[lo, hi]` bounds on the distance field — if `lo > 0`, the entire region is outside the surface and can be skipped.

```rust
use alice_sdf::interval::{eval_interval, eval_lipschitz, Interval, Vec3Interval};
use alice_sdf::prelude::*;

let shape = SdfNode::sphere(1.0).subtract(SdfNode::box3d(0.5, 0.5, 0.5));

// Evaluate over a spatial region
let region = Vec3Interval::from_bounds(Vec3::new(2.0, 2.0, 2.0), Vec3::new(3.0, 3.0, 3.0));
let bounds = eval_interval(&shape, region);
// bounds.lo > 0 → entire region is outside, skip it

// Lipschitz constant for adaptive step sizing
let lip = eval_lipschitz(&shape); // 1.0 for distance-preserving shapes
```

Supports all 54 primitives, 12 operations, transforms, and modifiers. Used internally by relaxed sphere tracing and SDF-to-SDF collision for spatial pruning.

## Neural SDF

Pure-Rust MLP (multi-layer perceptron) that learns to approximate an SDF tree. No external ML dependencies. Useful for accelerating evaluation of complex trees with many nodes.

```rust
use alice_sdf::neural::{NeuralSdf, NeuralSdfConfig};
use alice_sdf::prelude::*;

let complex_scene = SdfNode::sphere(1.0)
    .smooth_union(SdfNode::box3d(0.5, 0.5, 0.5).translate(1.5, 0.0, 0.0), 0.3);

// Train (samples random points, evaluates tree, fits MLP)
let config = NeuralSdfConfig::default(); // 3 layers, 64 wide, positional encoding
let nsdf = NeuralSdf::train(&complex_scene, Vec3::splat(-3.0), Vec3::splat(3.0), &config);

// Evaluate (~10-100x faster than tree for complex scenes)
let d = nsdf.eval(Vec3::new(0.0, 0.0, 0.0));

// Save/load binary weights
let mut buf = Vec::new();
nsdf.save(&mut buf).unwrap();
let loaded = NeuralSdf::load(&mut &buf[..]).unwrap();
```

Features: Xavier initialization, Adam optimizer, positional encoding, ReLU activations, compact binary serialization (`b"NSDF"` format).

## SDF-to-SDF Collision

Grid-based contact detection between two SDF fields with interval arithmetic AABB pruning.

```rust
use alice_sdf::prelude::*;
use alice_sdf::collision::*;

let a = SdfNode::sphere(1.0);
let b = SdfNode::sphere(1.0).translate(1.5, 0.0, 0.0);
let aabb = Aabb { min: Vec3::splat(-3.0), max: Vec3::splat(3.0) };

// Fast boolean overlap test (early exit)
if sdf_overlap(&a, &b, &aabb, 16) {
    // Detailed contact points (sorted by depth, deepest first)
    let contacts = sdf_collide(&a, &b, &aabb, 32);
    for c in &contacts {
        println!("point={}, normal={}, depth={}", c.point, c.normal, c.depth);
    }
}

// Minimum separation distance (0.0 if overlapping)
let dist = sdf_distance(&a, &b, &aabb, 16);
```

| Function | Description |
|----------|-------------|
| `sdf_overlap()` | Boolean intersection test with early exit |
| `sdf_collide()` | Contact points with position, normal, and penetration depth |
| `sdf_distance()` | Minimum separation distance (upper bound) |

All functions use interval arithmetic to skip grid cells where either SDF is provably positive, typically pruning 80-95% of cells.

## Analytic Gradient

Single-pass gradient computation via chain rules and Jacobian transpose propagation. Replaces the default 6-evaluation finite-difference method with analytic derivatives where possible.

```rust
use alice_sdf::prelude::*;

let shape = SdfNode::sphere(1.0)
    .smooth_union(SdfNode::box3d(0.5, 0.5, 0.5).translate(1.0, 0.0, 0.0), 0.3);

// Analytic gradient (single tree pass)
let grad = eval_gradient(&shape, Vec3::new(0.5, 0.0, 0.0));

// Analytic normal (normalized gradient)
let n = eval_normal(&shape, Vec3::new(0.5, 0.0, 0.0));
```

| Component | Method | Coverage |
|-----------|--------|----------|
| **9 primitives** | Closed-form analytic | Sphere, Box3d, Plane, Cylinder, Torus, Capsule, InfiniteCylinder, Gyroid, SchwarzP |
| **44 primitives** | Numerical fallback (6 leaf evals) | All remaining complex primitives |
| **12 operations** | Chain rule | Union, Intersection, Subtraction + Smooth/Chamfer/Stairs variants |
| **4 transforms** | Jacobian transpose | Translate, Rotate, Scale, ScaleNonUniform |
| **10 modifiers** | Analytic Jacobian | Round, Onion, Elongate, Mirror, Revolution, Extrude, Twist, Bend, RepeatInfinite, RepeatFinite |
| **5 modifiers** | Numerical fallback | Noise, Taper, Displacement, PolarRepeat, SweepBezier |

For a tree of depth D with N leaf nodes, the standard numerical gradient requires `6 × (full tree eval)`. The analytic gradient requires at most N leaf evaluations plus ~6 per complex leaf — significantly cheaper for deep trees.

## Dual Contouring

Dual Contouring places one vertex per cell using QEF (Quadric Error Function) minimization, producing meshes that preserve sharp edges and corners better than Marching Cubes.

```rust
use alice_sdf::prelude::*;

let shape = SdfNode::box3d(1.0, 1.0, 1.0)
    .subtract(SdfNode::cylinder(0.3, 2.0));

let config = DualContouringConfig {
    resolution: 64,
    ..Default::default()
};

let mesh = dual_contouring(&shape, Vec3::splat(-2.0), Vec3::splat(2.0), &config);

// Compiled version for 2-5x speedup
let compiled = CompiledSdf::compile(&shape);
let mesh_fast = dual_contouring_compiled(&compiled, Vec3::splat(-2.0), Vec3::splat(2.0), &config);
```

| Feature | Marching Cubes | Dual Contouring |
|---------|---------------|-----------------|
| Sharp edges | Rounded off | Preserved |
| Vertex placement | Edge intersections | QEF-optimal per cell |
| Topology | Triangles from lookup table | Quads from shared edges |
| Best for | Organic shapes | Hard-surface / CAD models |

### Manifold Mesh Guarantee

Ensures watertight, manifold meshes suitable for physics, rendering, and 3D printing.

```rust
use alice_sdf::prelude::*;

let mesh = sdf_to_mesh(&shape, min, max, &MarchingCubesConfig::default());

// Validate
let report = validate_mesh(&mesh);
println!("{}", report); // Prints full validation report

// Repair
let repaired = MeshRepair::repair_all(&mesh, 1e-6);

// Quality metrics
let quality = compute_quality(&repaired);
println!("Avg aspect ratio: {}", quality.avg_aspect_ratio);
```

| Function | Description |
|----------|-------------|
| `validate_mesh()` | Non-manifold edge detection, boundary edges, degenerate triangles, duplicate vertices, normal consistency |
| `MeshRepair::remove_degenerate_triangles()` | Remove zero-area triangles |
| `MeshRepair::merge_duplicate_vertices()` | Spatial-hash based vertex welding |
| `MeshRepair::fix_normals()` | Fix inconsistent winding order |
| `MeshRepair::repair_all()` | Run all repairs in sequence |
| `compute_quality()` | Aspect ratio and area statistics |

## Texture Fitting (Texture-to-Formula)

Converts bitmap textures (PNG/JPG) into resolution-independent procedural noise formulas. The fitted formula can be rendered on GPU at **any resolution** without the original image.

```
texture(u,v) ≈ bias + Σᵢ aᵢ · noise(uv · fᵢ + φᵢ, seedᵢ)
```

The CPU noise implementation (`hash_noise_3d`) exactly matches the GPU version in WGSL/HLSL/GLSL, guaranteeing CPU fitting = GPU rendering.

### Pipeline

1. Load image → grayscale f32
2. DCT frequency analysis → dominant bands
3. Greedy octave-by-octave fitting (Nelder-Mead, SIMD f32x8 + rayon parallel)
4. Export as JSON parameters and/or standalone shader function

### CLI

```bash
# Basic: fit texture and print results
alice-sdf texture-fit granite.png

# Export JSON parameters + HLSL shader
alice-sdf texture-fit granite.png -o params.json --shader hlsl --shader-output granite.hlsl

# High quality: more octaves, higher PSNR target
alice-sdf texture-fit marble.png --octaves 12 --target-psnr 35.0 --iterations 2000
```

### Rust API

```rust
use alice_sdf::texture::{fit_texture, generate_shader, ShaderLanguage, TextureFitConfig};
use std::path::Path;

let config = TextureFitConfig {
    max_octaves: 8,
    target_psnr_db: 28.0,
    iterations_per_octave: 500,
    tileable: true,
};

let result = fit_texture(Path::new("granite.png"), &config).unwrap();
println!("PSNR: {:.1} dB, {} octaves", result.psnr_db, result.octaves[0].len());

// Generate standalone WGSL shader
let shader = generate_shader(&result, ShaderLanguage::Wgsl, "granite.png");
```

### Output Shader Languages

| Target | Function Signature | Use Case |
|--------|-------------------|----------|
| **WGSL** | `fn procedural_texture(uv: vec2<f32>) -> f32` | WebGPU, wgpu |
| **HLSL** | `float procedural_texture(float2 uv)` | Unity, Unreal, DirectX |
| **GLSL** | `float procedural_texture(vec2 uv)` | OpenGL, Vulkan |

## Raymarching

Sphere tracing for ray-SDF intersection with specialized optimizations:

| Function | Description |
|----------|-------------|
| `raymarch()` | Single ray intersection with sphere tracing |
| `raymarch_relaxed()` | Relaxed sphere tracing with Lipschitz-adaptive over-relaxation |
| `raymarch_batch()` | Batch ray evaluation |
| `raymarch_batch_parallel()` | Parallel batch via Rayon |
| `render_depth()` | Depth buffer rendering |
| `render_normals()` | Normal map rendering |

Features: dedicated Shadow/AO loops (skip normal computation), early exit for hard shadows, configurable iteration limits via `RaymarchConfig`.

### Relaxed Sphere Tracing

Uses `RaymarchConfig::relaxed(node)` to automatically compute the Lipschitz constant from the SDF tree and apply over-relaxation (ω ∈ [1, 2)) with safety fallback:

```rust
use alice_sdf::prelude::*;

let shape = SdfNode::sphere(1.0).twist(0.5);
let config = RaymarchConfig::relaxed(&shape); // auto Lipschitz
let ray = Ray::new(Vec3::new(-5.0, 0.0, 0.0), Vec3::X);
let hit = raymarch_with_config(&shape, ray, 20.0, &config);
```

Step formula: `step = d / L × ω` with safety check — if `d < prev_step - prev_dist`, falls back to `d / L`. Typically reaches surfaces in 30-50% fewer steps compared to standard sphere tracing.

## FFI & Language Bindings

### C/C++ (`include/alice_sdf.h`)

```c
#include "alice_sdf.h"

// Evaluate SDF
AliceSdfHandle sdf = alice_sdf_sphere(1.0);
float dist = alice_sdf_eval(sdf, 0.5, 0.0, 0.0);

// Generate mesh once, export to multiple formats
MeshHandle mesh = alice_sdf_generate_mesh(sdf, 64, 2.0);
alice_sdf_export_glb(mesh, NULL, "model.glb", 0, 0);
alice_sdf_export_fbx(mesh, NULL, "model.fbx", 0, 0);
alice_sdf_export_obj(mesh, NULL, "model.obj", 0, 0);
alice_sdf_free_mesh(mesh);
alice_sdf_free(sdf);
```

### C# / Unity (`bindings/AliceSdf.cs`)

```csharp
using AliceSdf;

var sdf = AliceSdf.Sphere(1.0f);
float dist = sdf.Eval(new Vector3(0.5f, 0f, 0f));
```

### Python (PyO3)

```bash
pip install alice-sdf  # or: maturin develop --features python
```

### FFI Mesh Export

| Function | Format | Notes |
|----------|--------|-------|
| `alice_sdf_generate_mesh` | — | Generate mesh once (returns `MeshHandle`) |
| `alice_sdf_export_obj` | `.obj` | Wavefront OBJ |
| `alice_sdf_export_glb` | `.glb` | Binary glTF 2.0 |
| `alice_sdf_export_fbx` | `.fbx` | Autodesk FBX |
| `alice_sdf_export_usda` | `.usda` | Universal Scene Description |
| `alice_sdf_export_alembic` | `.abc` | Alembic (Ogawa) |
| `alice_sdf_free_mesh` | — | Free mesh handle |

All export functions accept `MeshHandle` (pre-generated) or `SdfHandle` (generates on the fly).

### FFI Performance Hierarchy

| Function | Speed | Use Case |
|----------|-------|----------|
| `alice_sdf_eval_soa` | Fastest | Physics, particles, tracing |
| `alice_sdf_eval_compiled_batch` | Fast | General batch evaluation |
| `alice_sdf_eval_batch` | Medium | Convenience (auto-compile) |
| `alice_sdf_eval` | Slow | Debugging only |

## Feature Flags

| Feature | Description | Dependencies |
|---------|-------------|--------------|
| `cli` (default) | Command-line interface | clap |
| `python` | Python bindings | pyo3, numpy |
| `jit` | JIT native code compilation | cranelift |
| `gpu` | WebGPU compute shaders | wgpu, pollster, bytemuck |
| `glsl` | GLSL shader transpiler | - |
| `hlsl` | HLSL shader transpiler | - |
| `ffi` | C/C++/C# FFI bindings | lazy_static |
| `unity` | Unity integration | ffi + glsl |
| `unreal` | Unreal Engine integration | ffi + hlsl |
| `all-shaders` | All shader transpilers | gpu + hlsl + glsl |
| `texture-fit` | Texture-to-formula conversion | image, rayon, wide |
| `physics` | ALICE-Physics integration (SdfField trait) | alice-physics |

```bash
# Examples
cargo build --features "jit,gpu"          # JIT + GPU
cargo build --features unity              # Unity (FFI + GLSL)
cargo build --features unreal             # Unreal (FFI + HLSL)
cargo build --features "all-shaders,jit"  # Everything
cargo build --features physics             # ALICE-Physics integration
```

## Physics Bridge (ALICE-Physics Integration)

ALICE-SDF can serve as a collision shape backend for [ALICE-Physics](../ALICE-Physics), a deterministic 128-bit fixed-point physics engine. Instead of GJK/EPA on convex hulls, the physics engine samples the SDF distance field directly — O(1) per query with mathematically exact surfaces.

### How It Works

```
ALICE-Physics (Fix128 world)          ALICE-SDF (f32 world)
┌──────────────────────┐             ┌──────────────────────┐
│ PhysicsWorld         │             │ CompiledSdfField     │
│   bodies: Vec<Body>  │──query──▶  │   distance(x,y,z)→f32│
│   sdf_colliders: Vec │             │   normal(x,y,z)→Vec3 │
│   step(dt)           │◀─contact─  │   distance_and_normal │
│                      │             │     → (f32, Vec3)     │
│ Fix128 ←→ f32 bridge│             │ 4-eval tetrahedral    │
└──────────────────────┘             └──────────────────────┘
```

The `physics` feature gate enables the `SdfField` trait implementation. All coordinate conversion between Fix128 and f32 happens at the trait boundary.

### Enable

```toml
# Cargo.toml
[dependencies]
alice-sdf = { path = "../ALICE-SDF", features = ["physics"] }
```

### Usage (ALICE-SDF side)

```rust
use alice_sdf::prelude::*;
use alice_sdf::physics_bridge::CompiledSdfField;

// Create an SDF shape
let shape = SdfNode::sphere(1.0)
    .smooth_union(SdfNode::box3d(0.5, 0.5, 0.5), 0.2);

// Wrap as physics-ready field
let field = CompiledSdfField::new(shape);

// The field implements alice_physics::SdfField trait:
//   field.distance(x, y, z) → f32       (1 eval)
//   field.normal(x, y, z)   → (f32,f32,f32)  (4 evals, tetrahedral)
//   field.distance_and_normal(x, y, z)   → (f32, (f32,f32,f32))  (4 evals combined)
```

### Performance

| Operation | Evals | Notes |
|-----------|-------|-------|
| `distance()` | 1 | Single compiled SDF evaluation |
| `normal()` | 4 | Tetrahedral gradient (4 offset samples) |
| `distance_and_normal()` | 4 | Combined: distance ≈ avg of 4, normal from differences |

The 4-eval tetrahedral method computes both distance (average of 4 samples, O(epsilon²) error) and normal from the same 4 evaluations, saving 1 eval compared to the naive 1+4 approach.

### Integration with ALICE-Physics

See the [ALICE-Physics README](../ALICE-Physics/README.md#sdf-collider-alice-sdf-integration) for how to register `CompiledSdfField` as a physics collider.

## Testing

670+ tests across all modules (primitives, operations, transforms, modifiers, compiler, evaluators, BVH, I/O, mesh, shader transpilers, materials, animation, manifold, OBJ, glTF, FBX, USD, Alembic, Nanite, UV unwrap, mesh collision, decimation, LOD, adaptive MC, dual contouring, crispy utilities, BloomFilter, interval arithmetic, Lipschitz bounds, relaxed sphere tracing, neural SDF, SDF-to-SDF collision, analytic gradient). With `--features jit`, 684+ tests including JIT scalar and JIT SIMD backends.

```bash
cargo test
```

## CLI

```bash
# Display file info
alice-sdf info model.asdf

# Convert between formats (.asdf ↔ .asdf.json)
alice-sdf convert model.asdf -o model.asdf.json

# Export SDF to mesh (auto-detect format from extension)
alice-sdf export model.asdf -o model.glb
alice-sdf export model.asdf -o model.obj --resolution 128 --bounds 3.0
alice-sdf export model.asdf -o scene.usda
alice-sdf export model.asdf -o anim.abc
alice-sdf export model.asdf -o model.fbx

# Generate demo SDF
alice-sdf demo -o demo.asdf

# Benchmark evaluation
alice-sdf bench --points 1000000
```

Supported export formats: `.obj`, `.glb`, `.fbx`, `.usda`, `.abc`

## Performance

Benchmarked on Apple M3 Max, Rust 1.75+, `--release` build.

### Single Point Evaluation

| Primitive | Time |
|-----------|------|
| Sphere | 6.1 ns |
| Box3D | 5.0 ns |
| Cylinder | 8.0 ns |
| Torus | 9.3 ns |

| Operation | Time |
|-----------|------|
| Union (2 nodes) | 13.3 ns |
| Smooth Union | 21.4 ns |
| Complex tree (5 nodes) | 12.6 ns |
| Complex tree (10 nodes) | 51.5 ns |
| Complex tree (20 nodes) | 66.5 ns |

### Batch Evaluation Comparison (1M points)

| Mode | Throughput | ns/point | Feature |
|------|------------|----------|---------|
| CPU JIT SIMD | 977 M/s | 1.0 ns | `--features jit` |
| CPU Scalar | 307 M/s | 3.3 ns | default |
| CPU SIMD (VM) | 252 M/s | 4.0 ns | default |
| GPU Compute | 101 M/s | 9.9 ns | `--features gpu` |

### JIT Compilation

The JIT compiler generates native SIMD machine code using Cranelift, achieving the highest throughput. The original 15 primitives are fully supported in both JIT scalar and JIT SIMD (8-wide) backends. The 16 new IQ primitives are supported in interpreted, compiled VM, and shader transpiler modes.

**Deep Fried v2 optimizations:**
- **Division Exorcism** - all runtime divisions pre-computed as reciprocal multiplications at compile time
- **Branchless SIMD selection** - sign-bit extraction via `bitcast`/`sshr`/`bitselect` (zero-overhead on SSE/AVX/NEON)
- **FMA fusion** - fused multiply-add for reduced latency in complex primitives (Cone, RoundedCone, Pyramid)

### crispy.rs — Hardware-Native Math Utilities

Low-level branchless operations for hot inner loops. Trades sub-ULP precision for throughput.

| Function | Description |
|----------|-------------|
| `fast_recip(x)` | Fast `1/x` via hardware rcpss + Newton-Raphson (~0.02% error) |
| `fast_inv_sqrt(x)` | Quake III inverse sqrt + NR iteration (~0.175% error) |
| `fast_normalize_2d(gx, gz)` | Normalize 2D gradient using fast inverse sqrt |
| `select_f32(cond, a, b)` | Branchless cmov via bit manipulation |
| `branchless_min/max/clamp/abs` | Zero-branch arithmetic via `select_f32` |
| `BitMask64` | 64-element batch mask (AND/OR/NOT/popcnt via hardware) |
| `BloomFilter` | 4KB Bloom filter with FNV-1a double-hashing, O(1) membership test |
| `fnv1a_hash(data)` | FNV-1a 64-bit hash (fast, well-distributed) |

### Compiled Marching Cubes Performance

The compiled MC path (`sdf_to_mesh_compiled`) applies two key optimizations:

1. **SIMD Batch Grid Evaluation** — All grid points are collected into a `Vec<Vec3>`, then evaluated in one call to `eval_compiled_batch_simd_parallel` (8-wide SIMD + Rayon). Eliminates per-point function call overhead.

2. **Grid Finite-Difference Normals** — Vertex normals are computed from neighboring grid values (`values[x+1] - values[x-1]`) instead of 6 additional `eval_compiled` calls per vertex. Interior cells use zero eval calls for normals; boundary cells fall back to analytical normals.

```bash
# Run CLI benchmark
cargo run --features "cli,jit" --release -- bench --points 1000000
```

| Points | JIT SIMD | SIMD (VM) | Speedup |
|--------|----------|-----------|---------|
| 100K | 330 M/s | 197 M/s | 1.7x |
| 1M | 977 M/s | 252 M/s | 3.9x |

### SIMD 8-wide Evaluation

| Mode | Time (8 points) | Speedup |
|------|-----------------|---------|
| Scalar | 563 ns | 1.0x |
| SIMD | 143 ns | 3.9x |

### Marching Cubes (Sphere, bounds +/-2.0)

| Resolution | Time |
|------------|------|
| 16^3 | 140 us |
| 32^3 | 390 us |
| 64^3 | 1.64 ms |

### Raymarching

| Shape | Time per ray |
|-------|--------------|
| Sphere | 62 ns |
| Complex (smooth union + twist) | 178 ns |

### GPU Compute (WebGPU)

The GPU module provides WebGPU compute shaders with persistent buffer pooling for repeated evaluations.

**When to use GPU vs CPU:**

| Batch Size | Recommended | Reason |
|------------|-------------|--------|
| < 100K | CPU JIT SIMD | GPU transfer overhead dominates |
| 100K - 1M | CPU JIT SIMD | JIT still faster on M3 Max |
| > 1M | Test both | Depends on hardware and shape complexity |

Note: GPU performance varies significantly by hardware. On discrete GPUs, crossover point may be lower.

```rust
use alice_sdf::prelude::*;
use alice_sdf::compiled::{GpuEvaluator, WgslShader, GpuBufferPool};

let shape = SdfNode::sphere(1.0).smooth_union(SdfNode::box3d(0.5, 0.5, 0.5), 0.2);

// Create GPU evaluator (compiles SDF to WGSL)
let gpu = GpuEvaluator::new(&shape).unwrap();

// Single-shot batch evaluation
let points: Vec<Vec3> = (0..100000)
    .map(|i| Vec3::new(i as f32 * 0.01, 0.0, 0.0))
    .collect();
let distances = gpu.eval_batch(&points).unwrap();

// Persistent buffer pool for repeated evaluations (2-5x faster)
let mut pool = gpu.create_buffer_pool(100000);
for frame in 0..60 {
    let distances = gpu.eval_batch_pooled(&points, &mut pool).unwrap();
}

// Auto-tuned batch (splits large batches into optimal chunks)
let distances = gpu.eval_batch_auto(&points, &mut pool).unwrap();
```

Enable with: `cargo build --features gpu`

| Mode | Throughput (1M pts) |
|------|---------------------|
| CPU JIT SIMD | ~977 M/s |
| CPU SIMD (VM) | ~252 M/s |
| GPU Compute | ~101 M/s |

## WebAssembly (Browser)

ALICE-SDF runs in the browser via WebAssembly with WebGPU/Canvas2D support.

### npm Package (`@alice-sdf/wasm`)

```bash
npm install @alice-sdf/wasm
```

Full TypeScript type definitions included. Supports all 53 primitives, CSG operations, transforms, mesh conversion, and shader generation (WGSL/GLSL).

### Building the WASM Demo

```bash
cd examples/wasm-demo
wasm-pack build --target web
python3 -m http.server 8080
# Open http://localhost:8080
```

### Features

- **WebGPU Compute**: Hardware-accelerated evaluation (Chrome 113+, Edge 113+)
- **Canvas2D Fallback**: CPU raymarching for older browsers
- **Real-time Visualization**: Interactive shape editing and rendering

### Browser Compatibility

| Browser | WebGPU | Canvas2D |
|---------|--------|----------|
| Chrome 113+ | yes | yes |
| Edge 113+ | yes | yes |
| Firefox Nightly | yes (flag) | yes |
| Safari 18+ | yes | yes |
| Older browsers | no | yes |

## Benchmarking

Run benchmarks to compare evaluation modes:

```bash
# CPU benchmarks (interpreter, SIMD, BVH)
cargo bench --bench sdf_eval

# JIT + SoA throughput benchmarks
cargo bench --bench sdf_eval --features jit -- soa_throughput

# GPU vs CPU comparison
cargo bench --bench gpu_vs_cpu --features "jit,gpu"

# CLI quick benchmark
cargo run --features "cli,jit,gpu" --release -- bench --points 1000000

# View HTML report
open target/criterion/report/index.html
```

## Unity Demo: SDF Universe

The `unity-sdf-universe/` directory contains a full Unity demo showcasing ALICE-SDF capabilities:

**"5MB Procedural Universe"** - An entire procedural universe using only 5MB of code.

### Features

| Feature | Description |
|---------|-------------|
| **10M+ Particles** | GPU Compute Shader particle system at 60+ FPS |
| **4 Scene Types** | Cosmic, Terrain, Abstract, Fractal |
| **Infinite Resolution** | Raymarching + Procedural Texturing |
| **The Fractal Dive** | Microscope demo with x10,000+ zoom |

### Quick Start

```bash
# 1. Build Rust library
cargo build --release

# 2. Copy to Unity
cp target/release/libalice_sdf.dylib unity-sdf-universe/Assets/Plugins/  # macOS

# 3. Open in Unity 2022.3+
# 4. Open Assets/Scenes/SdfUniverse.unity
# 5. Press Play
```

### The Fractal Dive (Microscope Demo)

Demonstrates TRUE infinite resolution via raymarching:

- **SDF Formula**: `Subtract(Box, Repeat(Cross))` - single mathematical object
- **Raymarching**: Per-pixel SDF evaluation (128 steps)
- **Procedural Texturing**: Colors from FBM noise (never pixelates)
- **[R] key**: Toggle between Raymarching and Particles mode

See `unity-sdf-universe/README.md` for full documentation.

## VRChat Integration

The `vrchat-package/` directory provides a VRChat SDK package for SDF-based worlds and avatars.

- **ALICE-Shader** - HLSL raymarching kernel with dynamic LOD
- **ALICE-Udon** - UdonSharp SDF collider with pure C# math
- **ALICE-Baker v0.3** - Editor tool to generate optimized shader + Udon from `.asdf.json`
- **7 Sample Worlds** - Basic, Cosmic, Fractal, Mix, DeformableWall, Mochi, TerrainSculpt

See `vrchat-package/README.md` for full documentation.

## Unreal Engine 5 Integration

ALICE-SDF provides full UE5 support via HLSL transpiler and C FFI bindings.

```bash
# Build the plugin DLL
cargo build --release --features unreal
```

- **HLSL Transpiler** - Generate Custom Material Expression nodes
- **C++ FFI** - Native plugin with `alice_sdf.h` header
- **Blueprint-ready** - UFunction wrappers for visual scripting

See `docs/UNREAL_ENGINE.md` for detailed setup instructions.

## Godot Integration

ALICE-SDF works with Godot via glTF 2.0 import and GDExtension FFI.

- **glTF Pipeline** - Export `.glb` and import directly into Godot
- **GDNative/GDExtension** - Link `libalice_sdf` via C FFI
- **Visual Shader** - Use GLSL transpiler output in shader nodes

See `docs/GODOT_GUIDE.md` for integration guide.

## Documentation

| Document | Description |
|----------|-------------|
| [ALICE-View](../ALICE-View) | Real-time GPU raymarching viewer (wgpu, drag & drop) |
| [QUICKSTART](docs/QUICKSTART.md) | 5-minute getting started guide for all platforms |
| [ARCHITECTURE](docs/ARCHITECTURE.md) | 13-layer architecture deep dive |
| [API Reference](docs/API_REFERENCE.md) | Complete API reference |
| [Unreal Engine](docs/UNREAL_ENGINE.md) | UE5 setup and integration guide |
| [Python Guide](docs/PYTHON_GUIDE.md) | Python and Blender integration |
| [WASM Guide](docs/WASM_GUIDE.md) | WebAssembly deployment guide |
| [Godot Guide](docs/GODOT_GUIDE.md) | Godot integration guide |
| [Unity Setup](unity-sdf-universe/SETUP_GUIDE.md) | Unity project setup |
| [VRChat Package](vrchat-package/README.md) | VRChat SDK integration |

## License

**Open Core Model** - Free for creators, licensed for infrastructure.

| Component | License | Use Case |
|-----------|---------|----------|
| **Core Engine** (Rust) | MIT License | Hack away! |
| **Unity Integration** | ALICE Community License | Free for Indie & Game Dev |
| **Enterprise / Cloud Infra** | Commercial License | Contact for pricing |

### Free Use (No License Required)

- Personal projects
- Indie game development (any revenue)
- AAA game studios (shipped games)
- Educational & research
- Open source projects

### Commercial License Required

- Metaverse platforms (10,000+ MAU)
- Cloud streaming services (SaaS/PaaS)
- Infrastructure providers
- Competing products

See [LICENSE](LICENSE) (MIT) and [LICENSE-COMMUNITY](LICENSE-COMMUNITY) for details.

**Content you create (.asdf files, worlds, games) is 100% yours. No royalties.**

---

Copyright (c) 2025 Moroya Sakamoto
