# ALICE-SDF

**A.L.I.C.E. - Adaptive Lightweight Implicit Compression Engine**

> "Don't send polygons. Send the law of shapes."

## Overview

ALICE-SDF is a 3D/spatial data specialist that transmits **mathematical descriptions of shapes** (Signed Distance Functions) instead of polygon meshes. This enables:

- **10-1000x compression** compared to traditional mesh formats
- **Infinite resolution** - shapes are mathematically perfect at any scale
- **CSG operations** - boolean operations on shapes without mesh overhead
- **Real-time raymarching** - GPU-accelerated rendering
- **PBR materials** - metallic-roughness workflow compatible with UE5/Unity/Godot
- **Keyframe animation** - parametric deformation with timeline tracks
- **Asset pipeline** - OBJ import/export, glTF 2.0 (.glb) export, FBX export
- **Manifold mesh guarantee** - validation, repair, and quality metrics
- **Adaptive Marching Cubes** - octree-based mesh generation, detail where it matters
- **V-HACD convex decomposition** - automatic convex hull decomposition for physics
- **Attribute-preserving decimation** - QEM with UV/tangent/material boundary protection
- **Decimation-based LOD** - progressive LOD chain from high-res base mesh
- **53 primitives, 4 transforms, 15 modifiers** - rich shape vocabulary
- **7 evaluation modes** - interpreted, compiled VM, SIMD 8-wide, BVH, SoA batch, JIT, GPU
- **3 shader targets** - GLSL, WGSL, HLSL transpilation
- **Engine integrations** - Unity, Unreal Engine 5, VRChat, Godot, WebAssembly

## Text-to-3D Pipeline (Server)

ALICE-SDF includes a FastAPI server that converts **natural language text into real 3D geometry** via LLM-generated SDF trees.

```
User: "A medieval castle"  →  LLM (Claude/Gemini)  →  SDF JSON  →  ALICE-SDF  →  GLB/OBJ
         text                   ~5-50s                  20 nodes      <55ms        mesh
```

### Architecture

```
┌─────────────┐     ┌──────────────┐     ┌───────────────┐     ┌──────────┐
│  FastAPI     │     │  LLM Service │     │  SDF Service  │     │  Output  │
│  Server      │────▶│  Claude API  │────▶│  from_json()  │────▶│  GLB     │
│              │     │  Gemini API  │     │  compile()    │     │  OBJ     │
│  POST /gen   │     │  System      │     │  to_mesh()    │     │  JSON    │
│  WS /ws/gen  │     │  Prompt      │     │  export_glb() │     │  Viewer  │
│  GET /viewer │     └──────────────┘     └───────────────┘     └──────────┘
└─────────────┘
```

### API Endpoints

| Method | Path | Description |
|--------|------|-------------|
| `POST` | `/api/generate` | Text → 3D mesh (GLB/OBJ/JSON) |
| `POST` | `/api/validate` | Validate SDF JSON structure |
| `POST` | `/api/mesh` | SDF JSON → mesh (GLB/OBJ) |
| `GET` | `/api/examples` | List few-shot example scenes |
| `GET` | `/api/viewer` | Three.js GLB viewer (browser) |
| `GET` | `/api/health` | Server health check |
| `WS` | `/ws/generate` | Streaming generation with progressive preview |

### Generated Scene Gallery

Scenes generated by Gemini 2.5 Flash from natural language prompts:

| Prompt | Nodes | Vertices | Triangles | LLM Time |
|--------|-------|----------|-----------|----------|
| "A medieval castle with towers" | 18 | 2,105 | 4,248 | 49.4s |
| "A robot standing on a platform" | 18 | 750 | 1,184 | 17.5s |
| "An underwater coral reef scene" | 15 | 2,666 | 5,166 | 63.3s |
| "A simple mushroom on grass" | 9 | 8,237 | 16,224 | 6.6s |
| "火山地帯に宇宙船" (Volcanic terrain with spaceship) | 22 | 10,466 | 20,618 | 20.5s |

Hand-crafted few-shot examples (used in LLM system prompt):

| Scene | Description | Nodes | Vertices | Triangles |
|-------|-------------|-------|----------|-----------|
| `sphere_on_ground` | Sphere on a flat ground (Union + Plane) | 4 | 1,270 | 2,448 |
| `snowman` | 3-sphere snowman (SmoothUnion) | 8 | 422 | 840 |
| `castle_tower` | Tower with battlements (PolarRepeat) | 11 | 1,030 | 2,244 |
| `alien_mushroom_forest` | Mushroom grid (RepeatFinite + Torus stems) | 9 | 4,167 | 7,854 |
| `twisted_pillar` | Twisted box + floating hollow sphere (Twist + Onion) | 7 | 510 | 968 |
| `mechanical_gear` | Gear with teeth and axle hole (PolarRepeat + Subtraction) | 9 | 465 | 912 |

Scene JSON files are stored in [`server/examples/scenes/`](server/examples/scenes/).

### Quick Start (Server)

```bash
# 1. Build Python bindings
cd /path/to/ALICE-SDF
python -m venv .venv && source .venv/bin/activate
maturin develop --features python

# 2. Install server dependencies
pip install -r server/requirements.txt

# 3. Set API keys
export ANTHROPIC_API_KEY="sk-..."   # for Claude
export GOOGLE_API_KEY="AI..."       # for Gemini

# 4. Start server
uvicorn server.main:app --reload

# 5. Generate 3D from text
curl -X POST http://localhost:8000/api/generate \
  -H "Content-Type: application/json" \
  -d '{"prompt": "A snowman", "provider": "gemini", "resolution": 64}' \
  -o snowman.glb

# 6. Open browser viewer
open http://localhost:8000/api/viewer
```

### LLM Providers

| Provider | Model | Speed | Best For |
|----------|-------|-------|----------|
| Claude | Haiku 4.5 | ~2-5s | Simple scenes, fast iteration |
| Claude | Sonnet 4.5 | ~5-15s | Complex scenes, high accuracy |
| Gemini | 2.5 Flash | ~5-50s | Complex scenes (thinking model) |
| Gemini | 2.5 Pro | ~10-60s | Maximum quality |

### Performance Budget

| Step | Time | Notes |
|------|------|-------|
| LLM inference | 2-60s | Depends on model and complexity |
| JSON parse | <1ms | serde_json |
| SDF compile | ~1ms | SdfNode → CompiledSdf |
| Mesh generation (res=64) | ~45ms | Parallel Marching Cubes |
| GLB export | ~5ms | |
| **Total (excluding LLM)** | **<55ms** | Real-time capable |

### Robustness Features

- **JSON repair**: Automatic brace/bracket completion for truncated LLM output
- **Structure validation**: Pre-validates Boolean ops (a/b) and transforms (child) before Rust serde
- **Retry with feedback**: Up to 2 retries with error message fed back to LLM
- **Rate limit handling**: Automatic wait-and-retry on 429 errors
- **Complexity constraints**: System prompt limits scenes to 15-20 nodes, nesting depth ≤6

### Server Directory Structure

```
server/
├── main.py                  # FastAPI app, REST + WebSocket endpoints
├── config.py                # API keys, model config (env vars)
├── models.py                # Pydantic request/response models
├── services/
│   ├── llm_service.py       # Claude/Gemini API with retry logic
│   └── sdf_service.py       # alice_sdf wrapper (parse, mesh, export)
├── prompts/
│   ├── system_prompt.py     # 36-node-type SDF grammar for LLM
│   └── examples.py          # 6 few-shot examples
├── examples/
│   └── scenes/              # Pre-built scene JSON files
│       ├── sphere_on_ground.json
│       ├── snowman.json
│       ├── castle_tower.json
│       ├── alien_mushroom_forest.json
│       ├── twisted_pillar.json
│       └── mechanical_gear.json
├── static/
│   └── viewer.html          # Three.js GLB viewer
├── tests/
│   ├── test_api.py          # 7 API endpoint tests
│   ├── test_llm_service.py  # 17 JSON extraction/validation tests
│   └── test_sdf_service.py  # 13 SDF pipeline tests
└── requirements.txt
```

### Running Tests

```bash
source .venv/bin/activate
python -m pytest server/tests/ -v   # 37 tests, all passing
```

## ALICE-View (Real-time 3D Viewer)

**[ALICE-View](../ALICE-View)** is a native GPU raymarching viewer built with wgpu. It renders SDF trees directly on the GPU via WGSL transpilation — no mesh conversion needed.

```
SDF JSON → ALICE-SDF (WGSL transpile) → wgpu GPU Raymarching → Real-time 3D
              ~1ms                            60 FPS
```

### Features

- **GPU Raymarching** — SdfNode tree transpiled to WGSL shader, evaluated per-pixel on GPU
- **Drag & Drop** — Drop `.json` / `.asdf` / `.asdf.json` files onto the window
- **File Dialog** — File > Open (Ctrl+O) with format filters
- **Camera Controls** — Mouse orbit, scroll zoom, WASD movement
- **Live SDF Panel** — Node count, raymarching parameters (max steps, epsilon, AO)

### Supported Formats

| Extension | Format | Description |
|-----------|--------|-------------|
| `.json` | SDF JSON | Text-to-3D pipeline output, few-shot examples |
| `.asdf.json` | ALICE SDF JSON | Native ALICE-SDF JSON format |
| `.asdf` | ALICE SDF Binary | Compact binary with CRC32 |
| `.alice` / `.alz` | ALICE Legacy | Procedural content (Perlin, Fractal) |

### Quick Start

```bash
cd /path/to/ALICE-View

# Open a specific file
cargo run --bin alice-view -- path/to/scene.json

# Or launch empty and drag & drop files onto the window
cargo run --bin alice-view
```

### Keyboard Shortcuts

| Key | Action |
|-----|--------|
| `W/A/S/D` | Camera movement |
| `Mouse drag` | Orbit camera |
| `Scroll` | Zoom in/out |
| `Ctrl+O` | Open file dialog |
| `Q` | Quit |

### Viewing Text-to-3D Results

Generated scene JSON files from the Text-to-3D pipeline can be viewed directly:

```bash
# View a generated scene
cargo run --bin alice-view -- /path/to/ALICE-SDF/server/examples/scenes/snowman.json

# Or drag any of these onto the window:
#   server/examples/scenes/castle_tower.json
#   server/examples/scenes/mechanical_gear.json
#   server/examples/scenes/alien_mushroom_forest.json
```

---

## Core Concepts

### SDF (Signed Distance Function)

An SDF returns the shortest distance from any point to the surface:
- **Negative** = inside the shape
- **Zero** = on the surface
- **Positive** = outside the shape

### SdfNode Tree Structure

```
SdfNode
  |-- Primitive (53): Sphere, Box3D, Cylinder, Torus, Plane, Capsule, Cone, Ellipsoid,
  |                    RoundedCone, Pyramid, Octahedron, HexPrism, Link, Triangle, Bezier,
  |                    RoundedBox, CappedCone, CappedTorus, InfiniteCylinder, RoundedCylinder,
  |                    TriangularPrism, CutSphere, CutHollowSphere, DeathStar, SolidAngle,
  |                    Rhombus, Horseshoe, Vesica, InfiniteCone, Heart, Gyroid,
  |                    Tube, Barrel, Diamond, ChamferedCube, SchwarzP, Superellipsoid, RoundedX,
  |                    Pie, Trapezoid, Parallelogram, Tunnel, UnevenCapsule, Egg,
  |                    ArcShape, Moon, CrossShape, BlobbyCross, ParabolaSegment,
  |                    RegularPolygon, StarPolygon, Stairs, Helix
  |-- Operation: Union, Intersection, Subtraction, SmoothUnion, SmoothIntersection, SmoothSubtraction
  |-- Transform (4): Translate, Rotate, Scale, ScaleNonUniform
  |-- Modifier (15): Twist, Bend, RepeatInfinite, RepeatFinite, Noise, Round, Onion, Elongate,
  |                   Mirror, Revolution, Extrude, Taper, Displacement, PolarRepeat, Symmetry
  +-- WithMaterial: PBR material assignment (transparent to distance evaluation)
```

## Installation

### Rust

```bash
cargo add alice-sdf
```

### Python

```bash
pip install alice-sdf
```

## Usage

### Rust

```rust
use alice_sdf::prelude::*;

// Create a sphere with radius 1
let sphere = SdfNode::sphere(1.0);

// Subtract a box from it
let result = sphere.subtract(SdfNode::box3d(1.5, 1.5, 1.5));

// Evaluate distance at a point
let distance = eval(&result, glam::Vec3::ZERO);

// Convert to mesh
let mesh = sdf_to_mesh(
    &result,
    glam::Vec3::splat(-2.0),
    glam::Vec3::splat(2.0),
    &MarchingCubesConfig::default()
);
```

### Python

```python
import alice_sdf as sdf

# Create primitives
sphere = sdf.SdfNode.sphere(1.0)
box3d = sdf.SdfNode.box3d(2.0, 1.0, 1.0)

# CSG operations
result = sphere.subtract(box3d)

# Transform
translated = result.translate(1.0, 0.0, 0.0)

# Evaluate at points (NumPy array)
import numpy as np
points = np.array([[0.5, 0.0, 0.0], [1.0, 1.0, 1.0]], dtype=np.float32)
distances = sdf.eval_batch(translated, points)

# Convert to mesh
vertices, indices = sdf.to_mesh(translated, (-2.0, -2.0, -2.0), (2.0, 2.0, 2.0))
```

## Material System

PBR metallic-roughness material system compatible with glTF 2.0, UE5, Unity HDRP, and Godot.

### Material Properties

| Property | Type | Description |
|----------|------|-------------|
| `base_color` | `[f32; 4]` | RGBA base color (linear space) |
| `metallic` | `f32` | 0.0 = dielectric, 1.0 = metal |
| `roughness` | `f32` | 0.0 = mirror, 1.0 = diffuse |
| `emission` | `[f32; 3]` | Emissive color (RGB) |
| `emission_strength` | `f32` | Emissive intensity multiplier |
| `opacity` | `f32` | 0.0 = transparent, 1.0 = opaque |
| `ior` | `f32` | Index of refraction (glass=1.5, water=1.33) |
| `normal_scale` | `f32` | Normal map strength |

### Usage

```rust
use alice_sdf::prelude::*;

// Create materials
let gold = Material::metal("Gold", 1.0, 0.766, 0.336, 0.3);
let glass = Material::glass("Glass", 1.5);
let glow = Material::emissive("Neon", 0.0, 1.0, 0.0, 10.0);

// Material library
let mut lib = MaterialLibrary::new();
let gold_id = lib.add(gold);

// Assign material to shape
let sphere = SdfNode::sphere(1.0).with_material(gold_id);

// Generate mesh with AAA vertex format (UV, tangent, color, material_id)
let mesh = sdf_to_mesh(&sphere, Vec3::splat(-2.0), Vec3::splat(2.0), &MarchingCubesConfig::aaa(64));
```

### Vertex Format

The mesh vertex includes all attributes needed for AAA rendering:

| Attribute | Type | Description |
|-----------|------|-------------|
| `position` | `Vec3` | 3D position |
| `normal` | `Vec3` | Surface normal |
| `uv` | `Vec2` | Triplanar-projected texture coordinates |
| `tangent` | `Vec4` | Tangent (xyz=direction, w=handedness) |
| `color` | `[f32; 4]` | Vertex color (RGBA linear) |
| `material_id` | `u32` | Material library index |

## Animation System

Keyframe-based animation of SDF parameters for real-time deformation, morphing, and cinematic sequences.

### Features

- **Interpolation modes**: Linear, Cubic Bezier (Hermite), Step
- **Loop modes**: Once, Loop, PingPong
- **Timeline**: Multiple tracks with named parameters
- **AnimatedSdf**: Time-varying SDF evaluation
- **Morph**: Smooth blending between two SDF shapes

### Usage

```rust
use alice_sdf::prelude::*;

// Create a bouncing sphere animation
let sphere = SdfNode::sphere(1.0);

let mut timeline = Timeline::new("bounce");

let mut ty = Track::new("translate.y").with_loop(LoopMode::PingPong);
ty.add_keyframe(Keyframe::new(0.0, 0.0));
ty.add_keyframe(Keyframe::cubic(0.5, 3.0, 0.0, 0.0));
ty.add_keyframe(Keyframe::new(1.0, 0.0));
timeline.add_track(ty);

let animated = AnimatedSdf::new(sphere, timeline);

// Evaluate at time t=0.25
let node_at_t = animated.evaluate_at(0.25);
let distance = eval(&node_at_t, Vec3::ZERO);

// Morph between two shapes
let sphere = SdfNode::sphere(1.0);
let cube = SdfNode::box3d(1.0, 1.0, 1.0);
let morphed = morph(&sphere, &cube, 0.5); // 50% blend
```

### Supported Track Names

| Track | Description |
|-------|-------------|
| `translate.x/y/z` | Translation offset |
| `rotate.x/y/z` | Euler rotation (radians) |
| `scale` | Uniform scale factor |
| `twist` | Twist strength |
| `bend` | Bend curvature |

## File Formats

### .asdf (ALICE SDF Binary)

Compact binary format with CRC32 integrity check.

```
Header (16 bytes):
  - Magic: "ASDF" (4 bytes)
  - Version: u16 (2 bytes)
  - Flags: u16 (2 bytes)
  - Node count: u32 (4 bytes)
  - CRC32: u32 (4 bytes)

Body:
  - Bincode-serialized SdfTree
```

### .asdf.json (ALICE SDF JSON)

Human-readable JSON format for debugging, interoperability, and LLM generation.

```json
{
  "version": "0.1.0",
  "root": {
    "Subtraction": {
      "a": {"Sphere": {"radius": 1.0}},
      "b": {"Box3d": {"half_extents": [1.5, 1.5, 1.5]}}
    }
  },
  "metadata": null
}
```

This is the same format used by the Text-to-3D pipeline — LLMs generate this JSON directly.

### .obj (Wavefront OBJ)

Standard mesh format with material (.mtl) support.

```rust
use alice_sdf::prelude::*;

let mesh = sdf_to_mesh(&shape, min, max, &MarchingCubesConfig::aaa(64));
export_obj(&mesh, "model.obj", &ObjConfig::default(), Some(&mat_lib))?;
```

### .glb (glTF 2.0 Binary)

Industry-standard 3D format with PBR materials. Compatible with UE5, Unity, Blender, Godot, and web viewers.

```rust
use alice_sdf::prelude::*;

let mesh = sdf_to_mesh(&shape, min, max, &MarchingCubesConfig::aaa(64));
export_glb(&mesh, "model.glb", &GltfConfig::aaa(), Some(&mat_lib))?;
```

### Asset Pipeline Summary

| Format | Import | Export | Materials | Description |
|--------|--------|--------|-----------|-------------|
| `.asdf` | yes | yes | - | Native SDF binary (CRC32) |
| `.asdf.json` | yes | yes | - | Native SDF JSON |
| `.obj` | yes | yes | .mtl | Wavefront OBJ (universal DCC) |
| `.glb` | - | yes | PBR | glTF 2.0 binary (game engines) |
| `.fbx` | - | yes | PBR | FBX 7.4 ASCII/Binary (DCC tools) |

## Architecture

ALICE-SDF uses a 13-layer architecture. Each SDF feature is implemented across all layers:

```
Layer 1:  types.rs          -- SdfNode enum (AST definition)
Layer 2:  primitives/       -- Mathematical SDF formulas (Inigo Quilez)
Layer 3:  eval/             -- Recursive interpreter
Layer 4:  compiled/opcode   -- OpCode enum for VM
Layer 5:  compiled/instr    -- Instruction encoding (32-byte aligned)
Layer 6:  compiled/compiler -- AST -> instruction compilation
Layer 7:  compiled/eval     -- Stack-based VM evaluator
Layer 8:  compiled/eval_simd-- SIMD 8-wide evaluator (AVX2/NEON)
Layer 9:  compiled/eval_bvh -- BVH-accelerated evaluator (AABB pruning)
Layer 10: compiled/glsl     -- GLSL transpiler (Unity/OpenGL/Vulkan)
Layer 11: compiled/wgsl     -- WGSL transpiler (WebGPU)
Layer 12: compiled/hlsl     -- HLSL transpiler (DirectX/Unreal)
Layer 13: compiled/jit      -- JIT native code (Cranelift)
```

### Evaluation Modes

| Mode | Description | Use Case |
|------|-------------|----------|
| **Interpreted** | Recursive tree walk | Debugging, prototyping |
| **Compiled VM** | Stack-based bytecode | General purpose |
| **SIMD 8-wide** | 8 points in parallel (Vec3x8) | Batch evaluation |
| **BVH-accelerated** | AABB spatial pruning | Complex scenes |
| **SoA Batch** | Structure-of-Arrays memory layout | Cache-optimal SIMD batches |
| **JIT Native** | Cranelift machine code | Maximum throughput |
| **GPU Compute** | WGSL compute shaders | Massive batches |

### Shader Transpilers

| Target | Output | Use Case |
|--------|--------|----------|
| **GLSL** | OpenGL/Vulkan shaders | Unity, custom engines |
| **WGSL** | WebGPU shaders | Browser, wgpu |
| **HLSL** | DirectX shaders | Unreal Engine, DirectX |

## Mesh Module

### Conversion

| Function | Description |
|----------|-------------|
| `sdf_to_mesh()` | SDF to mesh via parallel marching cubes (Z-slab parallelization) |
| `mesh_to_sdf()` | Mesh to SDF via capsule approximation (edge-based) |
| `mesh_to_sdf_exact()` | Mesh to SDF via BVH exact distance (O(log n) queries) |

### Advanced Features

| Feature | Module | Description |
|---------|--------|-------------|
| **Hermite Data** | `mesh/hermite` | Position + normal extraction for Dual Contouring |
| **Primitive Fitting** | `mesh/primitive_fitting` | Detect sphere/box/cylinder in mesh data for CSG reconstruction |
| **Nanite Clusters** | `mesh/nanite` | UE5 Nanite-compatible hierarchical cluster generation |
| **LOD Generation** | `mesh/lod` | Level-of-detail chain generation for efficient rendering |
| **Decimation LOD** | `mesh/lod` | Progressive decimation-based LOD from high-res base mesh |
| **Adaptive MC** | `mesh/sdf_to_mesh` | Octree-based marching cubes with surface-adaptive subdivision |
| **Mesh Decimation** | `mesh/decimate` | QEM decimation with UV/tangent/material boundary preservation |
| **Convex Decomposition** | `mesh/collision` | V-HACD volumetric convex decomposition for physics |
| **Collision Primitives** | `mesh/collision` | AABB, bounding sphere, convex hull, simplified collision |
| **Lightmap UVs** | `mesh/lightmap` | Automatic lightmap UV generation (UV channel 1) |
| **Vertex Optimization** | `mesh/optimize` | Vertex cache optimization and deduplication |
| **Mesh BVH** | `mesh/bvh` | Bounding volume hierarchy for exact signed distance queries |
| **Manifold Validation** | `mesh/manifold` | Topology validation, repair, and quality metrics |

### Manifold Mesh Guarantee

Ensures watertight, manifold meshes suitable for physics, rendering, and 3D printing.

```rust
use alice_sdf::prelude::*;

let mesh = sdf_to_mesh(&shape, min, max, &MarchingCubesConfig::default());

// Validate
let report = validate_mesh(&mesh);
println!("{}", report); // Prints full validation report

// Repair
let repaired = MeshRepair::repair_all(&mesh, 1e-6);

// Quality metrics
let quality = compute_quality(&repaired);
println!("Avg aspect ratio: {}", quality.avg_aspect_ratio);
```

| Function | Description |
|----------|-------------|
| `validate_mesh()` | Non-manifold edge detection, boundary edges, degenerate triangles, duplicate vertices, normal consistency |
| `MeshRepair::remove_degenerate_triangles()` | Remove zero-area triangles |
| `MeshRepair::merge_duplicate_vertices()` | Spatial-hash based vertex welding |
| `MeshRepair::fix_normals()` | Fix inconsistent winding order |
| `MeshRepair::repair_all()` | Run all repairs in sequence |
| `compute_quality()` | Aspect ratio and area statistics |

## Texture Fitting (Texture-to-Formula)

Converts bitmap textures (PNG/JPG) into resolution-independent procedural noise formulas. The fitted formula can be rendered on GPU at **any resolution** without the original image.

```
texture(u,v) ≈ bias + Σᵢ aᵢ · noise(uv · fᵢ + φᵢ, seedᵢ)
```

The CPU noise implementation (`hash_noise_3d`) exactly matches the GPU version in WGSL/HLSL/GLSL, guaranteeing CPU fitting = GPU rendering.

### Pipeline

1. Load image → grayscale f32
2. DCT frequency analysis → dominant bands
3. Greedy octave-by-octave fitting (Nelder-Mead, SIMD f32x8 + rayon parallel)
4. Export as JSON parameters and/or standalone shader function

### CLI

```bash
# Basic: fit texture and print results
alice-sdf texture-fit granite.png

# Export JSON parameters + HLSL shader
alice-sdf texture-fit granite.png -o params.json --shader hlsl --shader-output granite.hlsl

# High quality: more octaves, higher PSNR target
alice-sdf texture-fit marble.png --octaves 12 --target-psnr 35.0 --iterations 2000
```

### Rust API

```rust
use alice_sdf::texture::{fit_texture, generate_shader, ShaderLanguage, TextureFitConfig};
use std::path::Path;

let config = TextureFitConfig {
    max_octaves: 8,
    target_psnr_db: 28.0,
    iterations_per_octave: 500,
    tileable: true,
};

let result = fit_texture(Path::new("granite.png"), &config).unwrap();
println!("PSNR: {:.1} dB, {} octaves", result.psnr_db, result.octaves[0].len());

// Generate standalone WGSL shader
let shader = generate_shader(&result, ShaderLanguage::Wgsl, "granite.png");
```

### Output Shader Languages

| Target | Function Signature | Use Case |
|--------|-------------------|----------|
| **WGSL** | `fn procedural_texture(uv: vec2<f32>) -> f32` | WebGPU, wgpu |
| **HLSL** | `float procedural_texture(float2 uv)` | Unity, Unreal, DirectX |
| **GLSL** | `float procedural_texture(vec2 uv)` | OpenGL, Vulkan |

## Raymarching

Sphere tracing for ray-SDF intersection with specialized optimizations:

| Function | Description |
|----------|-------------|
| `raymarch()` | Single ray intersection with sphere tracing |
| `raymarch_batch()` | Batch ray evaluation |
| `raymarch_batch_parallel()` | Parallel batch via Rayon |
| `render_depth()` | Depth buffer rendering |
| `render_normals()` | Normal map rendering |

Features: dedicated Shadow/AO loops (skip normal computation), early exit for hard shadows, configurable iteration limits via `RaymarchConfig`.

## FFI & Language Bindings

### C/C++ (`include/alice_sdf.h`)

```c
#include "alice_sdf.h"

AliceSdfHandle sdf = alice_sdf_sphere(1.0);
float dist = alice_sdf_eval(sdf, 0.5, 0.0, 0.0);
```

### C# / Unity (`bindings/AliceSdf.cs`)

```csharp
using AliceSdf;

var sdf = AliceSdf.Sphere(1.0f);
float dist = sdf.Eval(new Vector3(0.5f, 0f, 0f));
```

### Python (PyO3)

```bash
pip install alice-sdf  # or: maturin develop --features python
```

### FFI Performance Hierarchy

| Function | Speed | Use Case |
|----------|-------|----------|
| `alice_sdf_eval_soa` | Fastest | Physics, particles, tracing |
| `alice_sdf_eval_compiled_batch` | Fast | General batch evaluation |
| `alice_sdf_eval_batch` | Medium | Convenience (auto-compile) |
| `alice_sdf_eval` | Slow | Debugging only |

## Feature Flags

| Feature | Description | Dependencies |
|---------|-------------|--------------|
| `cli` (default) | Command-line interface | clap |
| `python` | Python bindings | pyo3, numpy |
| `jit` | JIT native code compilation | cranelift |
| `gpu` | WebGPU compute shaders | wgpu, pollster, bytemuck |
| `glsl` | GLSL shader transpiler | - |
| `hlsl` | HLSL shader transpiler | - |
| `ffi` | C/C++/C# FFI bindings | lazy_static |
| `unity` | Unity integration | ffi + glsl |
| `unreal` | Unreal Engine integration | ffi + hlsl |
| `all-shaders` | All shader transpilers | gpu + hlsl + glsl |
| `texture-fit` | Texture-to-formula conversion | image, rayon, wide |

```bash
# Examples
cargo build --features "jit,gpu"          # JIT + GPU
cargo build --features unity              # Unity (FFI + GLSL)
cargo build --features unreal             # Unreal (FFI + HLSL)
cargo build --features "all-shaders,jit"  # Everything
```

## Testing

546+ tests across all modules (primitives, operations, transforms, modifiers, compiler, evaluators, BVH, I/O, mesh, shader transpilers, materials, animation, manifold, OBJ, glTF, FBX, collision, decimation, LOD, adaptive MC). With `--features jit`, 570+ tests including JIT scalar and JIT SIMD backends.

```bash
cargo test
```

## Performance

Benchmarked on Apple M3 Max, Rust 1.75+, `--release` build.

### Single Point Evaluation

| Primitive | Time |
|-----------|------|
| Sphere | 6.1 ns |
| Box3D | 5.0 ns |
| Cylinder | 8.0 ns |
| Torus | 9.3 ns |

| Operation | Time |
|-----------|------|
| Union (2 nodes) | 13.3 ns |
| Smooth Union | 21.4 ns |
| Complex tree (5 nodes) | 12.6 ns |
| Complex tree (10 nodes) | 51.5 ns |
| Complex tree (20 nodes) | 66.5 ns |

### Batch Evaluation Comparison (1M points)

| Mode | Throughput | ns/point | Feature |
|------|------------|----------|---------|
| CPU JIT SIMD | 977 M/s | 1.0 ns | `--features jit` |
| CPU Scalar | 307 M/s | 3.3 ns | default |
| CPU SIMD (VM) | 252 M/s | 4.0 ns | default |
| GPU Compute | 101 M/s | 9.9 ns | `--features gpu` |

### JIT Compilation

The JIT compiler generates native SIMD machine code using Cranelift, achieving the highest throughput. The original 15 primitives are fully supported in both JIT scalar and JIT SIMD (8-wide) backends. The 16 new IQ primitives are supported in interpreted, compiled VM, and shader transpiler modes.

**Deep Fried v2 optimizations:**
- **Division Exorcism** - all runtime divisions pre-computed as reciprocal multiplications at compile time
- **Branchless SIMD selection** - sign-bit extraction via `bitcast`/`sshr`/`bitselect` (zero-overhead on SSE/AVX/NEON)
- **FMA fusion** - fused multiply-add for reduced latency in complex primitives (Cone, RoundedCone, Pyramid)

```bash
# Run CLI benchmark
cargo run --features "cli,jit" --release -- bench --points 1000000
```

| Points | JIT SIMD | SIMD (VM) | Speedup |
|--------|----------|-----------|---------|
| 100K | 330 M/s | 197 M/s | 1.7x |
| 1M | 977 M/s | 252 M/s | 3.9x |

### SIMD 8-wide Evaluation

| Mode | Time (8 points) | Speedup |
|------|-----------------|---------|
| Scalar | 563 ns | 1.0x |
| SIMD | 143 ns | 3.9x |

### Marching Cubes (Sphere, bounds +/-2.0)

| Resolution | Time |
|------------|------|
| 16^3 | 140 us |
| 32^3 | 390 us |
| 64^3 | 1.64 ms |

### Raymarching

| Shape | Time per ray |
|-------|--------------|
| Sphere | 62 ns |
| Complex (smooth union + twist) | 178 ns |

### GPU Compute (WebGPU)

The GPU module provides WebGPU compute shaders with persistent buffer pooling for repeated evaluations.

**When to use GPU vs CPU:**

| Batch Size | Recommended | Reason |
|------------|-------------|--------|
| < 100K | CPU JIT SIMD | GPU transfer overhead dominates |
| 100K - 1M | CPU JIT SIMD | JIT still faster on M3 Max |
| > 1M | Test both | Depends on hardware and shape complexity |

Note: GPU performance varies significantly by hardware. On discrete GPUs, crossover point may be lower.

```rust
use alice_sdf::prelude::*;
use alice_sdf::compiled::{GpuEvaluator, WgslShader, GpuBufferPool};

let shape = SdfNode::sphere(1.0).smooth_union(SdfNode::box3d(0.5, 0.5, 0.5), 0.2);

// Create GPU evaluator (compiles SDF to WGSL)
let gpu = GpuEvaluator::new(&shape).unwrap();

// Single-shot batch evaluation
let points: Vec<Vec3> = (0..100000)
    .map(|i| Vec3::new(i as f32 * 0.01, 0.0, 0.0))
    .collect();
let distances = gpu.eval_batch(&points).unwrap();

// Persistent buffer pool for repeated evaluations (2-5x faster)
let mut pool = gpu.create_buffer_pool(100000);
for frame in 0..60 {
    let distances = gpu.eval_batch_pooled(&points, &mut pool).unwrap();
}

// Auto-tuned batch (splits large batches into optimal chunks)
let distances = gpu.eval_batch_auto(&points, &mut pool).unwrap();
```

Enable with: `cargo build --features gpu`

| Mode | Throughput (1M pts) |
|------|---------------------|
| CPU JIT SIMD | ~977 M/s |
| CPU SIMD (VM) | ~252 M/s |
| GPU Compute | ~101 M/s |

## WebAssembly (Browser)

ALICE-SDF runs in the browser via WebAssembly with WebGPU/Canvas2D support.

### Building the WASM Demo

```bash
cd examples/wasm-demo
wasm-pack build --target web
python3 -m http.server 8080
# Open http://localhost:8080
```

### Features

- **WebGPU Compute**: Hardware-accelerated evaluation (Chrome 113+, Edge 113+)
- **Canvas2D Fallback**: CPU raymarching for older browsers
- **Real-time Visualization**: Interactive shape editing and rendering

### Browser Compatibility

| Browser | WebGPU | Canvas2D |
|---------|--------|----------|
| Chrome 113+ | yes | yes |
| Edge 113+ | yes | yes |
| Firefox Nightly | yes (flag) | yes |
| Safari 18+ | yes | yes |
| Older browsers | no | yes |

## Benchmarking

Run benchmarks to compare evaluation modes:

```bash
# CPU benchmarks (interpreter, SIMD, BVH)
cargo bench --bench sdf_eval

# JIT + SoA throughput benchmarks
cargo bench --bench sdf_eval --features jit -- soa_throughput

# GPU vs CPU comparison
cargo bench --bench gpu_vs_cpu --features "jit,gpu"

# CLI quick benchmark
cargo run --features "cli,jit,gpu" --release -- bench --points 1000000

# View HTML report
open target/criterion/report/index.html
```

## Unity Demo: SDF Universe

The `unity-sdf-universe/` directory contains a full Unity demo showcasing ALICE-SDF capabilities:

**"5MB Procedural Universe"** - An entire procedural universe using only 5MB of code.

### Features

| Feature | Description |
|---------|-------------|
| **10M+ Particles** | GPU Compute Shader particle system at 60+ FPS |
| **4 Scene Types** | Cosmic, Terrain, Abstract, Fractal |
| **Infinite Resolution** | Raymarching + Procedural Texturing |
| **The Fractal Dive** | Microscope demo with x10,000+ zoom |

### Quick Start

```bash
# 1. Build Rust library
cargo build --release

# 2. Copy to Unity
cp target/release/libalice_sdf.dylib unity-sdf-universe/Assets/Plugins/  # macOS

# 3. Open in Unity 2022.3+
# 4. Open Assets/Scenes/SdfUniverse.unity
# 5. Press Play
```

### The Fractal Dive (Microscope Demo)

Demonstrates TRUE infinite resolution via raymarching:

- **SDF Formula**: `Subtract(Box, Repeat(Cross))` - single mathematical object
- **Raymarching**: Per-pixel SDF evaluation (128 steps)
- **Procedural Texturing**: Colors from FBM noise (never pixelates)
- **[R] key**: Toggle between Raymarching and Particles mode

See `unity-sdf-universe/README.md` for full documentation.

## VRChat Integration

The `vrchat-package/` directory provides a VRChat SDK package for SDF-based worlds and avatars.

- **ALICE-Shader** - HLSL raymarching kernel with dynamic LOD
- **ALICE-Udon** - UdonSharp SDF collider with pure C# math
- **ALICE-Baker v0.3** - Editor tool to generate optimized shader + Udon from `.asdf.json`
- **7 Sample Worlds** - Basic, Cosmic, Fractal, Mix, DeformableWall, Mochi, TerrainSculpt

See `vrchat-package/README.md` for full documentation.

## Unreal Engine 5 Integration

ALICE-SDF provides full UE5 support via HLSL transpiler and C FFI bindings.

```bash
# Build the plugin DLL
cargo build --release --features unreal
```

- **HLSL Transpiler** - Generate Custom Material Expression nodes
- **C++ FFI** - Native plugin with `alice_sdf.h` header
- **Blueprint-ready** - UFunction wrappers for visual scripting

See `docs/UNREAL_ENGINE.md` for detailed setup instructions.

## Godot Integration

ALICE-SDF works with Godot via glTF 2.0 import and GDExtension FFI.

- **glTF Pipeline** - Export `.glb` and import directly into Godot
- **GDNative/GDExtension** - Link `libalice_sdf` via C FFI
- **Visual Shader** - Use GLSL transpiler output in shader nodes

See `docs/GODOT_GUIDE.md` for integration guide.

## Documentation

| Document | Description |
|----------|-------------|
| [ALICE-View](../ALICE-View) | Real-time GPU raymarching viewer (wgpu, drag & drop) |
| [QUICKSTART](docs/QUICKSTART.md) | 5-minute getting started guide for all platforms |
| [ARCHITECTURE](docs/ARCHITECTURE.md) | 13-layer architecture deep dive |
| [API Reference](docs/API_REFERENCE.md) | Complete API reference |
| [Unreal Engine](docs/UNREAL_ENGINE.md) | UE5 setup and integration guide |
| [Python Guide](docs/PYTHON_GUIDE.md) | Python and Blender integration |
| [WASM Guide](docs/WASM_GUIDE.md) | WebAssembly deployment guide |
| [Godot Guide](docs/GODOT_GUIDE.md) | Godot integration guide |
| [Unity Setup](unity-sdf-universe/SETUP_GUIDE.md) | Unity project setup |
| [VRChat Package](vrchat-package/README.md) | VRChat SDK integration |

## License

**Open Core Model** - Free for creators, licensed for infrastructure.

| Component | License | Use Case |
|-----------|---------|----------|
| **Core Engine** (Rust) | MIT License | Hack away! |
| **Unity Integration** | ALICE Community License | Free for Indie & Game Dev |
| **Enterprise / Cloud Infra** | Commercial License | Contact for pricing |

### Free Use (No License Required)

- Personal projects
- Indie game development (any revenue)
- AAA game studios (shipped games)
- Educational & research
- Open source projects

### Commercial License Required

- Metaverse platforms (10,000+ MAU)
- Cloud streaming services (SaaS/PaaS)
- Infrastructure providers
- Competing products

See [LICENSE](LICENSE) (MIT) and [LICENSE-COMMUNITY](LICENSE-COMMUNITY) for details.

**Content you create (.asdf files, worlds, games) is 100% yours. No royalties.**

---

Copyright (c) 2025 Moroya Sakamoto
