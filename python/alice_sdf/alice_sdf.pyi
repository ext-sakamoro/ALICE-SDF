"""Type stubs for alice_sdf native module (PyO3)."""

from typing import List, Optional, Tuple

import numpy as np
import numpy.typing as npt

# ---------------------------------------------------------------------------
# SdfNode
# ---------------------------------------------------------------------------

class SdfNode:
    """SDF node representing a shape or CSG tree."""

    # --- Primitive constructors ---

    @staticmethod
    def sphere(radius: float) -> SdfNode: ...
    @staticmethod
    def box3d(width: float, height: float, depth: float) -> SdfNode: ...
    @staticmethod
    def cylinder(radius: float, height: float) -> SdfNode: ...
    @staticmethod
    def torus(major_radius: float, minor_radius: float) -> SdfNode: ...
    @staticmethod
    def capsule(
        ax: float, ay: float, az: float, bx: float, by: float, bz: float, radius: float
    ) -> SdfNode: ...
    @staticmethod
    def plane(nx: float, ny: float, nz: float, distance: float) -> SdfNode: ...
    @staticmethod
    def cone(radius: float, height: float) -> SdfNode: ...
    @staticmethod
    def ellipsoid(rx: float, ry: float, rz: float) -> SdfNode: ...
    @staticmethod
    def rounded_cone(r1: float, r2: float, height: float) -> SdfNode: ...
    @staticmethod
    def pyramid(height: float) -> SdfNode: ...
    @staticmethod
    def octahedron(size: float) -> SdfNode: ...
    @staticmethod
    def hex_prism(hex_radius: float, height: float) -> SdfNode: ...
    @staticmethod
    def link(length: float, r1: float, r2: float) -> SdfNode: ...
    @staticmethod
    def triangle(
        ax: float, ay: float, az: float,
        bx: float, by: float, bz: float,
        cx: float, cy: float, cz: float,
    ) -> SdfNode: ...
    @staticmethod
    def bezier(
        ax: float, ay: float, az: float,
        bx: float, by: float, bz: float,
        cx: float, cy: float, cz: float,
        radius: float,
    ) -> SdfNode: ...
    @staticmethod
    def rounded_box(hx: float, hy: float, hz: float, round_radius: float) -> SdfNode: ...
    @staticmethod
    def capped_cone(height: float, r1: float, r2: float) -> SdfNode: ...
    @staticmethod
    def capped_torus(major_radius: float, minor_radius: float, cap_angle: float) -> SdfNode: ...
    @staticmethod
    def rounded_cylinder(radius: float, round_radius: float, height: float) -> SdfNode: ...
    @staticmethod
    def triangular_prism(width: float, depth: float) -> SdfNode: ...
    @staticmethod
    def cut_sphere(radius: float, cut_height: float) -> SdfNode: ...
    @staticmethod
    def cut_hollow_sphere(radius: float, cut_height: float, thickness: float) -> SdfNode: ...
    @staticmethod
    def death_star(ra: float, rb: float, d: float) -> SdfNode: ...
    @staticmethod
    def solid_angle(angle: float, radius: float) -> SdfNode: ...
    @staticmethod
    def rhombus(la: float, lb: float, height: float, round_radius: float) -> SdfNode: ...
    @staticmethod
    def horseshoe(
        angle: float, radius: float, length: float, width: float, thickness: float
    ) -> SdfNode: ...
    @staticmethod
    def vesica(radius: float, dist: float) -> SdfNode: ...
    @staticmethod
    def infinite_cylinder(radius: float) -> SdfNode: ...
    @staticmethod
    def infinite_cone(angle: float) -> SdfNode: ...
    @staticmethod
    def gyroid(scale: float, thickness: float) -> SdfNode: ...
    @staticmethod
    def heart(size: float) -> SdfNode: ...
    @staticmethod
    def tube(outer_radius: float, thickness: float, height: float) -> SdfNode: ...
    @staticmethod
    def barrel(radius: float, height: float, bulge: float) -> SdfNode: ...
    @staticmethod
    def diamond_shape(radius: float, height: float) -> SdfNode: ...
    @staticmethod
    def chamfered_cube(width: float, height: float, depth: float, chamfer: float) -> SdfNode: ...
    @staticmethod
    def schwarz_p(scale: float, thickness: float) -> SdfNode: ...
    @staticmethod
    def superellipsoid(
        width: float, height: float, depth: float, e1: float, e2: float
    ) -> SdfNode: ...
    @staticmethod
    def rounded_x(width: float, round_radius: float, height: float) -> SdfNode: ...
    @staticmethod
    def pie(angle: float, radius: float, height: float) -> SdfNode: ...
    @staticmethod
    def trapezoid(r1: float, r2: float, trap_height: float, depth: float) -> SdfNode: ...
    @staticmethod
    def parallelogram(
        width: float, para_height: float, skew: float, depth: float
    ) -> SdfNode: ...
    @staticmethod
    def tunnel(width: float, height_2d: float, depth: float) -> SdfNode: ...
    @staticmethod
    def uneven_capsule(r1: float, r2: float, cap_height: float, depth: float) -> SdfNode: ...
    @staticmethod
    def egg(ra: float, rb: float) -> SdfNode: ...
    @staticmethod
    def arc_shape(
        aperture: float, radius: float, thickness: float, height: float
    ) -> SdfNode: ...
    @staticmethod
    def moon(d: float, ra: float, rb: float, height: float) -> SdfNode: ...
    @staticmethod
    def cross_shape(
        length: float, thickness: float, round_radius: float, height: float
    ) -> SdfNode: ...
    @staticmethod
    def blobby_cross(size: float, height: float) -> SdfNode: ...
    @staticmethod
    def parabola_segment(width: float, para_height: float, depth: float) -> SdfNode: ...
    @staticmethod
    def regular_polygon(radius: float, n_sides: int, height: float) -> SdfNode: ...
    @staticmethod
    def star_polygon(radius: float, n_points: int, m: float, height: float) -> SdfNode: ...
    @staticmethod
    def stairs_shape(
        step_width: float, step_height: float, n_steps: int, depth: float
    ) -> SdfNode: ...
    @staticmethod
    def helix(major_r: float, minor_r: float, pitch: float, height: float) -> SdfNode: ...
    @staticmethod
    def tetrahedron(size: float) -> SdfNode: ...
    @staticmethod
    def dodecahedron(radius: float) -> SdfNode: ...
    @staticmethod
    def icosahedron(radius: float) -> SdfNode: ...
    @staticmethod
    def truncated_octahedron(radius: float) -> SdfNode: ...
    @staticmethod
    def truncated_icosahedron(radius: float) -> SdfNode: ...
    @staticmethod
    def box_frame(hx: float, hy: float, hz: float, edge: float) -> SdfNode: ...
    @staticmethod
    def diamond_surface(scale: float, thickness: float) -> SdfNode: ...
    @staticmethod
    def neovius(scale: float, thickness: float) -> SdfNode: ...
    @staticmethod
    def lidinoid(scale: float, thickness: float) -> SdfNode: ...
    @staticmethod
    def iwp(scale: float, thickness: float) -> SdfNode: ...
    @staticmethod
    def frd(scale: float, thickness: float) -> SdfNode: ...
    @staticmethod
    def fischer_koch_s(scale: float, thickness: float) -> SdfNode: ...
    @staticmethod
    def pmy(scale: float, thickness: float) -> SdfNode: ...
    @staticmethod
    def circle_2d(radius: float, half_height: float) -> SdfNode: ...
    @staticmethod
    def rect_2d(half_w: float, half_h: float, half_height: float) -> SdfNode: ...
    @staticmethod
    def segment_2d(
        ax: float, ay: float, bx: float, by: float, thickness: float, half_height: float
    ) -> SdfNode: ...
    @staticmethod
    def polygon_2d(vertices: List[Tuple[float, float]], half_height: float) -> SdfNode: ...
    @staticmethod
    def rounded_rect_2d(
        half_w: float, half_h: float, round_radius: float, half_height: float
    ) -> SdfNode: ...
    @staticmethod
    def annular_2d(outer_radius: float, thickness: float, half_height: float) -> SdfNode: ...

    # --- Evaluation ---

    def eval(self, x: float, y: float, z: float) -> float: ...
    def gradient(self, x: float, y: float, z: float) -> Tuple[float, float, float]: ...
    def tight_aabb(
        self,
        initial_half_size: float = 10.0,
        bisection_iterations: int = 20,
        coarse_subdivisions: int = 8,
    ) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]: ...
    def optimize(self) -> SdfNode: ...
    def node_count(self) -> int: ...

    # --- Boolean / blending operations ---

    def union(self, other: SdfNode) -> SdfNode: ...
    def intersection(self, other: SdfNode) -> SdfNode: ...
    def subtract(self, other: SdfNode) -> SdfNode: ...
    def smooth_union(self, other: SdfNode, k: float) -> SdfNode: ...
    def smooth_intersection(self, other: SdfNode, k: float) -> SdfNode: ...
    def smooth_subtract(self, other: SdfNode, k: float) -> SdfNode: ...
    def exp_smooth_union(self, other: SdfNode, k: float) -> SdfNode: ...
    def exp_smooth_intersection(self, other: SdfNode, k: float) -> SdfNode: ...
    def exp_smooth_subtract(self, other: SdfNode, k: float) -> SdfNode: ...
    def xor(self, other: SdfNode) -> SdfNode: ...
    def morph(self, other: SdfNode, t: float) -> SdfNode: ...
    def columns_union(self, other: SdfNode, r: float, n: float) -> SdfNode: ...
    def columns_intersection(self, other: SdfNode, r: float, n: float) -> SdfNode: ...
    def columns_subtract(self, other: SdfNode, r: float, n: float) -> SdfNode: ...
    def pipe(self, other: SdfNode, r: float) -> SdfNode: ...
    def engrave(self, other: SdfNode, r: float) -> SdfNode: ...
    def groove(self, other: SdfNode, ra: float, rb: float) -> SdfNode: ...
    def tongue(self, other: SdfNode, ra: float, rb: float) -> SdfNode: ...
    def chamfer_union(self, other: SdfNode, r: float) -> SdfNode: ...
    def chamfer_intersection(self, other: SdfNode, r: float) -> SdfNode: ...
    def chamfer_subtract(self, other: SdfNode, r: float) -> SdfNode: ...
    def stairs_union(self, other: SdfNode, r: float, n: float) -> SdfNode: ...
    def stairs_intersection(self, other: SdfNode, r: float, n: float) -> SdfNode: ...
    def stairs_subtract(self, other: SdfNode, r: float, n: float) -> SdfNode: ...

    # --- Transforms ---

    def translate(self, x: float, y: float, z: float) -> SdfNode: ...
    def rotate(self, x: float, y: float, z: float) -> SdfNode: ...
    def scale(self, factor: float) -> SdfNode: ...
    def scale_xyz(self, x: float, y: float, z: float) -> SdfNode: ...
    def twist(self, strength: float) -> SdfNode: ...
    def bend(self, curvature: float) -> SdfNode: ...
    def repeat(self, spacing_x: float, spacing_y: float, spacing_z: float) -> SdfNode: ...
    def noise(self, amplitude: float, frequency: float, seed: int) -> SdfNode: ...
    def round(self, radius: float) -> SdfNode: ...
    def onion(self, thickness: float) -> SdfNode: ...
    def mirror(self, x: bool, y: bool, z: bool) -> SdfNode: ...
    def octant_mirror(self) -> SdfNode: ...
    def elongate(self, x: float, y: float, z: float) -> SdfNode: ...
    def repeat_finite(
        self,
        count_x: int, count_y: int, count_z: int,
        spacing_x: float, spacing_y: float, spacing_z: float,
    ) -> SdfNode: ...
    def revolution(self, offset: float) -> SdfNode: ...
    def extrude(self, height: float) -> SdfNode: ...
    def taper(self, factor: float) -> SdfNode: ...
    def displacement(self, strength: float) -> SdfNode: ...
    def polar_repeat(self, count: int) -> SdfNode: ...
    def with_material(self, material_id: int) -> SdfNode: ...
    def sweep_bezier(
        self, p0x: float, p0y: float, p1x: float, p1y: float, p2x: float, p2y: float
    ) -> SdfNode: ...
    def shear(self, xy: float, xz: float, yz: float) -> SdfNode: ...
    def animated(self, speed: float, amplitude: float) -> SdfNode: ...
    def projective_transform(
        self, inv_matrix: List[float], lipschitz_bound: float
    ) -> SdfNode: ...
    def lattice_deform(
        self,
        control_points: List[List[float]],
        nx: int, ny: int, nz: int,
        bbox_min: List[float],
        bbox_max: List[float],
    ) -> SdfNode: ...
    def sdf_skinning(
        self, bones: List[Tuple[List[float], List[float], float]]
    ) -> SdfNode: ...
    def icosahedral_symmetry(self) -> SdfNode: ...
    def ifs(self, transforms: List[List[float]], iterations: int) -> SdfNode: ...
    def heightmap_displacement(
        self,
        heightmap: List[float],
        width: int, height: int,
        amplitude: float, scale: float,
    ) -> SdfNode: ...
    def surface_roughness(
        self, frequency: float, amplitude: float, octaves: int
    ) -> SdfNode: ...

    # --- Operator overloads ---

    def __or__(self, other: SdfNode) -> SdfNode: ...
    def __and__(self, other: SdfNode) -> SdfNode: ...
    def __sub__(self, other: SdfNode) -> SdfNode: ...
    def __repr__(self) -> str: ...

# ---------------------------------------------------------------------------
# CompiledSdf
# ---------------------------------------------------------------------------

class CompiledSdf:
    """Compiled SDF for fast evaluation (bytecode VM + SIMD)."""

    def eval(self, x: float, y: float, z: float) -> float: ...
    def eval_batch(
        self, points: npt.NDArray[np.float32]
    ) -> npt.NDArray[np.float32]: ...
    def to_mesh(
        self,
        bounds_min: Tuple[float, float, float],
        bounds_max: Tuple[float, float, float],
        resolution: int = 64,
    ) -> Tuple[npt.NDArray[np.float32], npt.NDArray[np.uint32]]: ...
    def instruction_count(self) -> int: ...
    def __repr__(self) -> str: ...

# ---------------------------------------------------------------------------
# MeshCache
# ---------------------------------------------------------------------------

class MeshCache:
    """Chunked mesh cache with FIFO eviction."""

    def __init__(self, max_chunks: int = 256, chunk_size: float = 1.0) -> None: ...
    def __len__(self) -> int: ...
    def is_empty(self) -> bool: ...
    def memory_usage(self) -> int: ...
    def clear(self) -> None: ...

# ---------------------------------------------------------------------------
# Core functions
# ---------------------------------------------------------------------------

def compile_sdf(node: SdfNode) -> CompiledSdf: ...

def eval_batch(
    node: SdfNode, points: npt.NDArray[np.float32]
) -> npt.NDArray[np.float32]: ...

def eval_compiled_batch(
    compiled: CompiledSdf, points: npt.NDArray[np.float32]
) -> npt.NDArray[np.float32]: ...

def eval_compiled_batch_soa(
    compiled: CompiledSdf, points: npt.NDArray[np.float32]
) -> npt.NDArray[np.float32]: ...

def to_mesh(
    node: SdfNode,
    bounds_min: Tuple[float, float, float],
    bounds_max: Tuple[float, float, float],
    resolution: int = 64,
) -> Tuple[npt.NDArray[np.float32], npt.NDArray[np.uint32]]: ...

def to_mesh_adaptive(
    node: SdfNode,
    bounds_min: Tuple[float, float, float],
    bounds_max: Tuple[float, float, float],
    max_depth: int = 6,
    min_depth: int = 2,
    surface_threshold: float = 1.0,
) -> Tuple[npt.NDArray[np.float32], npt.NDArray[np.uint32]]: ...

def to_mesh_dual_contouring(
    node: SdfNode,
    bounds_min: Tuple[float, float, float],
    bounds_max: Tuple[float, float, float],
    resolution: int = 64,
) -> Tuple[npt.NDArray[np.float32], npt.NDArray[np.uint32]]: ...

def decimate_mesh(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
    target_ratio: float = 0.5,
    preserve_boundary: bool = True,
) -> Tuple[npt.NDArray[np.float32], npt.NDArray[np.uint32]]: ...

def version() -> str: ...

# ---------------------------------------------------------------------------
# I/O functions
# ---------------------------------------------------------------------------

def save_sdf(node: SdfNode, path: str) -> None: ...
def load_sdf(path: str) -> SdfNode: ...
def from_json(json_str: str) -> SdfNode: ...
def to_json(node: SdfNode) -> str: ...

def export_obj(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
    path: str,
) -> None: ...

def export_glb(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
    path: str,
) -> None: ...

def export_glb_bytes(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
) -> bytes: ...

def export_fbx(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
    path: str,
) -> None: ...

def export_usda(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
    path: str,
) -> None: ...

def export_alembic(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
    path: str,
) -> None: ...

def uv_unwrap(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
) -> Tuple[npt.NDArray[np.float32], npt.NDArray[np.float32], npt.NDArray[np.uint32]]: ...

def save_abm(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
    path: str,
) -> None: ...

def load_abm(
    path: str,
) -> Tuple[npt.NDArray[np.float32], npt.NDArray[np.uint32]]: ...

def export_unity(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
    path: str,
    flip_z: bool = True,
    flip_winding: bool = True,
    scale: float = 1.0,
) -> None: ...

def export_ue5(
    vertices: npt.NDArray[np.float32],
    indices: npt.NDArray[np.uint32],
    path: str,
    scale: float = 100.0,
) -> None: ...
