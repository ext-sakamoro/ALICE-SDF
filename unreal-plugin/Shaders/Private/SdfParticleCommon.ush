#include "/Engine/Public/Platform.ush"

// =============================================================================
// ALICE-SDF Particle Compute - Common Functions
// =============================================================================
// Shared SDF primitives, CSG operations, noise, and random functions.
// Included by all scene compute shaders.
//
// Author: Moroya Sakamoto
// =============================================================================

#pragma once

// =============================================================================
// Data Structures
// =============================================================================

struct FParticle
{
	float3 Position;
	float3 Velocity;
	float Life;
	float _Pad;
};

// =============================================================================
// SDF Primitives
// =============================================================================

float sdSphere(float3 p, float r)
{
	return length(p) - r;
}

float sdBox(float3 p, float3 b)
{
	float3 q = abs(p) - b;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdTorus(float3 p, float2 t)
{
	float2 q = float2(length(p.xz) - t.x, p.y);
	return length(q) - t.y;
}

float sdOctahedron(float3 p, float s)
{
	p = abs(p);
	return (p.x + p.y + p.z - s) * 0.57735027;
}

float sdGyroid(float3 p, float scale, float thickness)
{
	p *= scale;
	float g = dot(sin(p), cos(p.yzx));
	return abs(g) / scale - thickness;
}

float sdSchwarzP(float3 p, float scale, float thickness)
{
	p *= scale;
	float s = cos(p.x) + cos(p.y) + cos(p.z);
	return abs(s) / scale - thickness;
}

float sdCross(float3 p, float size)
{
	float inf = 1000.0;
	float da = sdBox(p, float3(inf, size, size));
	float db = sdBox(p, float3(size, inf, size));
	float dc = sdBox(p, float3(size, size, inf));
	return min(da, min(db, dc));
}

float sdPlane(float3 p, float3 n, float h)
{
	return dot(p, n) + h;
}

// =============================================================================
// SDF Operations
// =============================================================================

float opSmoothUnion(float d1, float d2, float k)
{
	float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
	return lerp(d2, d1, h) - k * h * (1.0 - h);
}

float opSmoothIntersection(float d1, float d2, float k)
{
	float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
	return lerp(d2, d1, h) + k * h * (1.0 - h);
}

float opSmoothSubtraction(float d1, float d2, float k)
{
	float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
	return lerp(d2, -d1, h) + k * h * (1.0 - h);
}

float opSubtraction(float d1, float d2)
{
	return max(-d1, d2);
}

float opUnion(float d1, float d2)
{
	return min(d1, d2);
}

// Infinite repetition
float3 opRepeat(float3 p, float3 c)
{
	return fmod(p + c * 0.5, c) - c * 0.5;
}

// =============================================================================
// Rotation Matrices
// =============================================================================

float3 opRotateX(float3 p, float angle)
{
	float c = cos(angle);
	float s = sin(angle);
	return float3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);
}

float3 opRotateY(float3 p, float angle)
{
	float c = cos(angle);
	float s = sin(angle);
	return float3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);
}

float3x3 rotateX(float a)
{
	float c = cos(a), s = sin(a);
	return float3x3(1, 0, 0, 0, c, -s, 0, s, c);
}

float3x3 rotateY(float a)
{
	float c = cos(a), s = sin(a);
	return float3x3(c, 0, s, 0, 1, 0, -s, 0, c);
}

float3x3 rotateZ(float a)
{
	float c = cos(a), s = sin(a);
	return float3x3(c, -s, 0, s, c, 0, 0, 0, 1);
}

// =============================================================================
// Noise Functions
// =============================================================================

float hash(float3 p)
{
	p = frac(p * 0.3183099 + 0.1);
	p *= 17.0;
	return frac(p.x * p.y * p.z * (p.x + p.y + p.z));
}

float noise(float3 p)
{
	float3 i = floor(p);
	float3 f = frac(p);
	f = f * f * (3.0 - 2.0 * f);

	return lerp(
		lerp(lerp(hash(i + float3(0,0,0)), hash(i + float3(1,0,0)), f.x),
			 lerp(hash(i + float3(0,1,0)), hash(i + float3(1,1,0)), f.x), f.y),
		lerp(lerp(hash(i + float3(0,0,1)), hash(i + float3(1,0,1)), f.x),
			 lerp(hash(i + float3(0,1,1)), hash(i + float3(1,1,1)), f.x), f.y),
		f.z
	);
}

float fbm(float3 p, int octaves)
{
	float value = 0.0;
	float amplitude = 0.5;
	float frequency = 1.0;

	for (int i = 0; i < octaves; i++)
	{
		value += amplitude * noise(p * frequency);
		amplitude *= 0.5;
		frequency *= 2.0;
	}

	return value;
}

// =============================================================================
// Random (PCG)
// =============================================================================

uint pcg(uint v)
{
	uint state = v * 747796405u + 2891336453u;
	uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
	return (word >> 22u) ^ word;
}

float randomFloat(uint seed)
{
	return float(pcg(seed)) / 4294967295.0;
}

float3 randomDirection(uint seed)
{
	float theta = randomFloat(seed) * 6.28318;
	float phi = acos(2.0 * randomFloat(seed + 1u) - 1.0);
	return float3(
		sin(phi) * cos(theta),
		sin(phi) * sin(theta),
		cos(phi)
	);
}

float3 hash33(uint seed)
{
	return float3(
		randomFloat(seed),
		randomFloat(seed + 7919u),
		randomFloat(seed + 104729u)
	);
}

// =============================================================================
// Gradient (Normal) via Central Differences
// =============================================================================
// Note: Each scene defines its own sceneSDF(), then calls this.
// sceneSDF() must be defined before including this macro.
// =============================================================================

#define CALC_NORMAL(p) calcNormal(p)

// Each scene .usf will define:
//   float sceneSDF(float3 p);
//   float3 calcNormal(float3 p);

// =============================================================================
// Common Physics Update
// =============================================================================

void surfaceFlowPhysics(
	inout float3 pos,
	inout float3 vel,
	float dist,
	float3 normal,
	float flowSpeed,
	float surfaceAttraction,
	float noiseStrength,
	float deltaTime,
	float time,
	float maxDistance,
	float spawnRadius,
	uint particleId)
{
	// 1. Project velocity onto surface tangent
	float vDotN = dot(vel, normal);
	vel -= vDotN * normal;

	// 2. Add rotational flow
	float3 tangent = cross(normal, float3(0, 1, 0));
	if (length(tangent) < 0.01)
	{
		tangent = cross(normal, float3(1, 0, 0));
	}
	tangent = normalize(tangent);
	vel += tangent * flowSpeed * 0.5;

	// 3. Surface attraction
	vel -= normal * dist * surfaceAttraction;

	// 4. Add noise
	if (noiseStrength > 0)
	{
		float3 noiseOffset = float3(
			noise(pos * 0.1 + float3(time * 0.3, 0, 0)) - 0.5,
			noise(pos * 0.1 + float3(0, time * 0.3, 0)) - 0.5,
			noise(pos * 0.1 + float3(0, 0, time * 0.3)) - 0.5
		);
		vel += noiseOffset * noiseStrength;
	}

	// 5. Clamp velocity
	float velLen = length(vel);
	if (velLen > flowSpeed * 2.0)
	{
		vel = vel / velLen * flowSpeed * 2.0;
	}

	// 6. Integrate
	pos += vel * deltaTime;

	// 7. Respawn if out of bounds
	float distFromOrigin = length(pos);
	if (distFromOrigin > maxDistance || isnan(pos.x))
	{
		uint seed = particleId + asuint(time * 1000.0);
		pos = randomDirection(seed) * randomFloat(seed + 1u) * spawnRadius;
		vel = randomDirection(seed + 2u) * 0.5;
	}
}
